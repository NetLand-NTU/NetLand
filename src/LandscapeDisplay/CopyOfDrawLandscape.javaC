package LandscapeDisplay;

import java.awt.CardLayout;
import java.awt.Frame;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import cern.colt.matrix.DoubleMatrix1D;
import cern.colt.matrix.DoubleMatrix2D;
import cern.colt.matrix.doublealgo.Statistic;
import cern.colt.matrix.doublealgo.Transform;
import cern.colt.matrix.impl.DenseDoubleMatrix1D;
import cern.colt.matrix.impl.DenseDoubleMatrix2D;
import ch.epfl.lis.animation.Snake;
import ch.epfl.lis.gnw.CancelException;
import ch.epfl.lis.gnw.GeneNetwork;
import ch.epfl.lis.gnw.GnwSettings;
import edu.umbc.cs.maple.utils.ColtUtils;


public class CopyOfDrawLandscape {
	private GeneNetwork grn_;
	
	private int its = 100;
	private int maxTime = 1;
	private int numTimePoints = 21;	
	private double[][] gridData = null;
	private String outputPath;
	
	/** Layout of the main panel of the dialog. */
	protected final CardLayout myCardLayout_ = new CardLayout();
	protected Snake snake_;
	
	private DoubleMatrix2D sumPara;
	private int[] counts;
	//size is num attractors with indexes 
	private	ArrayList<int[]> labeledSeries;
	private boolean isStable;
	
	
	public CopyOfDrawLandscape(JFrame frame, GeneNetwork grn, double max, int its, int maxTime, int numTimePoints, String[] focusGenes, String outputPath, String landscapeMethod, boolean displayMethod, int gpdmItsValue) {
		this.grn_ = grn;
		this.its = its;
		this.maxTime = maxTime;
		this.numTimePoints = numTimePoints;
		this.outputPath = outputPath;
		
		
		try {
			checkForInterruption();
		} catch (CancelException e) {
			JOptionPane.showMessageDialog(new Frame(), "The program is interrupted!", "Cancel", JOptionPane.INFORMATION_MESSAGE);
			MsgManager.Messages.errorMessage(e, "Cancel", "");
		}
		
		/** generate time series **/
		ArrayList<DoubleMatrix2D> timeSeries = new ArrayList<DoubleMatrix2D>();
		ArrayList<DoubleMatrix1D> theta = new ArrayList<DoubleMatrix1D>();

		try {
			calculatePara(timeSeries, max, theta, displayMethod);
		} catch (Exception e) {
			JOptionPane.showMessageDialog(new Frame(), "Error in execution!", "Runtime exception", JOptionPane.INFORMATION_MESSAGE);
			MsgManager.Messages.errorMessage(e, "Runtime exception", "");
		}
		

		try {
			checkForInterruption();
		} catch (CancelException e) {
			JOptionPane.showMessageDialog(new Frame(), "The program is interrupted!", "Cancel", JOptionPane.INFORMATION_MESSAGE);
			MsgManager.Messages.errorMessage(e, "Cancel", "");
		}
		
		grn_.setDisplayMethod(landscapeMethod);
		
		//get attractors focusGenes=all
		if( !checkAttractor(focusGenes, timeSeries, theta) ){
			isStable = false;
			return;
		}
		
		isStable = true;
		//visualization setting
		if( displayMethod ){ //two markers// not gpdm
						
			try {
				checkForInterruption();
			} catch (CancelException e) {
				JOptionPane.showMessageDialog(new Frame(), "The program is interrupted!", "Cancel", JOptionPane.INFORMATION_MESSAGE);
				MsgManager.Messages.errorMessage(e, "Cancel", "");
			}
			
			grn_.setCounts(counts);
			grn_.setSumPara(sumPara);
			grn_.setLand_isTwoGenes(true);
			
			grn_.setLand_maxTime(maxTime);
			grn_.setLand_itsValue(its);
			grn_.setLand_maxExpValue(max);
			grn_.setLand_focusGenesList(focusGenes);
			grn_.setLand_gpdmitsValue(gpdmItsValue);
			
		}else if( !displayMethod ){//gpdm
			//calculate Ua
			int exitVal = -2;
			
			//first round of GPDM
			try {
				//write svml
				//input file
				String filename = "temp_"+System.currentTimeMillis();
				String temppath = System.getProperty("java.io.tmpdir");
				File f = new File(temppath);
				File fTemp = File.createTempFile(filename, ".svml", f);

				URL url = fTemp.toURI().toURL();
				int numYorig = writeSVML(url,timeSeries,labeledSeries);		

				//output file
				String outputModelName = "temp_"+System.currentTimeMillis();
				File fout = new File(temppath);
				File fTempout = File.createTempFile(outputModelName, ".gpdm", fout);

				//run GPDM
				exitVal = runGPDM(temppath,fTemp.getName(),fTempout.getName(),gpdmItsValue);

				if( exitVal == 0 ){
					//interpolate new points
					String outputNewPointName = "temp_"+System.currentTimeMillis();
					File fnew = new File(temppath);
					File fTempnew = File.createTempFile(outputNewPointName, ".ypred", fnew);

					runMyGPDM(temppath, fTempout.getName(), fTempnew.getName());

					int nPerDim=31;
					//get new Y and new X
					DoubleMatrix2D allY = new DenseDoubleMatrix2D(nPerDim*nPerDim,grn_.getNodes().size());
					DoubleMatrix2D allX = new DenseDoubleMatrix2D(nPerDim*nPerDim,2); //numYorig+
					double minX=0, maxX=0, minY=0, maxY=0; int n=0;

					String tempString = getYandX(fTempnew, allY, allX);

					//System.out.print(tempString);
					String temp1[] = tempString.split("\t");
					maxX = Double.parseDouble(temp1[0]);
					minX = Double.parseDouble(temp1[1]);
					maxY = Double.parseDouble(temp1[2]);
					minY = Double.parseDouble(temp1[3]);
					n = Integer.parseInt(temp1[4]);

					try {
						checkForInterruption();
					} catch (CancelException e) {
						JOptionPane.showMessageDialog(new Frame(), "The program is interrupted!", "Cancel", JOptionPane.INFORMATION_MESSAGE);
						MsgManager.Messages.errorMessage(e, "Cancel", "");
					}

					grn_.setCounts(counts);
					grn_.setSumPara(sumPara);
					grn_.setMinX(minX);
					grn_.setMaxX(maxX);
					grn_.setMinY(minY);
					grn_.setMaxY(maxY);
					grn_.setN(n);
					grn_.setAllX(allX);
					grn_.setAllY(allY);
					grn_.setLand_isTwoGenes(false);

					fTemp.delete();
					fTempout.delete();
					fTempnew.delete();

					grn_.setLand_maxTime(maxTime);
					grn_.setLand_itsValue(its);
					grn_.setLand_maxExpValue(max);
					grn_.setLand_focusGenesList(focusGenes);
					grn_.setLand_gpdmitsValue(gpdmItsValue);
					return;
				}//end of exitVal == 0 
			} catch (IOException e) {
				JOptionPane.showMessageDialog(new Frame(), "Cannot create a file!", "Error", JOptionPane.INFORMATION_MESSAGE);
				MsgManager.Messages.errorMessage(e, "Error", "");
				return;
			}	
			
			
			//in case of "Matrix non positive definite error"
			while( exitVal == -2 ){ 
				//regenerate traj
				try {
					checkForInterruption();
				} catch (CancelException e) {
					JOptionPane.showMessageDialog(new Frame(), "The program is interrupted!", "Cancel", JOptionPane.INFORMATION_MESSAGE);
					MsgManager.Messages.errorMessage(e, "Cancel", "");
				}
				
				timeSeries = new ArrayList<DoubleMatrix2D>();
				theta = new ArrayList<DoubleMatrix1D>();

				try {
					calculatePara(timeSeries, max, theta, displayMethod);
				} catch (Exception e) {
					JOptionPane.showMessageDialog(new Frame(), "Error in execution!", "Runtime exception", JOptionPane.INFORMATION_MESSAGE);
					MsgManager.Messages.errorMessage(e, "Runtime exception", "");
				}
				

				try {
					checkForInterruption();
				} catch (CancelException e) {
					JOptionPane.showMessageDialog(new Frame(), "The program is interrupted!", "Cancel", JOptionPane.INFORMATION_MESSAGE);
					MsgManager.Messages.errorMessage(e, "Cancel", "");
				}
				
				try {
					//write svml
					//input file
					String filename = "temp_"+System.currentTimeMillis();
					String temppath = System.getProperty("java.io.tmpdir");
					File f = new File(temppath);
					File fTemp = File.createTempFile(filename, ".svml", f);

					URL url = fTemp.toURI().toURL();
					int numYorig = writeSVML(url,timeSeries,labeledSeries);		

					//output file
					String outputModelName = "temp_"+System.currentTimeMillis();
					File fout = new File(temppath);
					File fTempout = File.createTempFile(outputModelName, ".gpdm", fout);

					//run GPDM
					exitVal = runGPDM(temppath,fTemp.getName(),fTempout.getName(),gpdmItsValue);

					if( exitVal == 0 ){
						//interpolate new points
						String outputNewPointName = "temp_"+System.currentTimeMillis();
						File fnew = new File(temppath);
						File fTempnew = File.createTempFile(outputNewPointName, ".ypred", fnew);

						runMyGPDM(temppath, fTempout.getName(), fTempnew.getName());

						int nPerDim=31;
						//get new Y and new X
						DoubleMatrix2D allY = new DenseDoubleMatrix2D(nPerDim*nPerDim,grn_.getNodes().size());
						DoubleMatrix2D allX = new DenseDoubleMatrix2D(nPerDim*nPerDim,2); //numYorig+
						double minX=0, maxX=0, minY=0, maxY=0; int n=0;

						String tempString = getYandX(fTempnew, allY, allX);

						//System.out.print(tempString);
						String temp1[] = tempString.split("\t");
						maxX = Double.parseDouble(temp1[0]);
						minX = Double.parseDouble(temp1[1]);
						maxY = Double.parseDouble(temp1[2]);
						minY = Double.parseDouble(temp1[3]);
						n = Integer.parseInt(temp1[4]);

						try {
							checkForInterruption();
						} catch (CancelException e) {
							JOptionPane.showMessageDialog(new Frame(), "The program is interrupted!", "Cancel", JOptionPane.INFORMATION_MESSAGE);
							MsgManager.Messages.errorMessage(e, "Cancel", "");
						}

						grn_.setCounts(counts);
						grn_.setSumPara(sumPara);
						grn_.setMinX(minX);
						grn_.setMaxX(maxX);
						grn_.setMinY(minY);
						grn_.setMaxY(maxY);
						grn_.setN(n);
						grn_.setAllX(allX);
						grn_.setAllY(allY);
						grn_.setLand_isTwoGenes(false);

						fTemp.delete();
						fTempout.delete();
						fTempnew.delete();

						grn_.setLand_maxTime(maxTime);
						grn_.setLand_itsValue(its);
						grn_.setLand_maxExpValue(max);
						grn_.setLand_focusGenesList(focusGenes);
						grn_.setLand_gpdmitsValue(gpdmItsValue);
						
						return;
					}//end of exitVal == 0
				} catch (IOException e) {
					JOptionPane.showMessageDialog(new Frame(), "Cannot create a file!", "Error", JOptionPane.INFORMATION_MESSAGE);
					MsgManager.Messages.errorMessage(e, "Error", "");
					return;
				}		
			}//end of while
			
		}//end of display	
				
	}

	
	//read Ypred Y and Xold Xnew from files
	private String getYandX(File fTempnew, DoubleMatrix2D allY, DoubleMatrix2D allX) {
		String paras = "";
		
		//get ogrinal Y and X
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new FileReader(fTempnew));
            String tempString = null;
            //get minX maxX minY maxY
            tempString = reader.readLine();
            paras = tempString;
            
            int line = 0;
            while ((tempString = reader.readLine()) != null) {
            	String temp[] = tempString.split("\t");
            	for(int i=0;i<allY.columns();i++)
            		allY.set(line, i, Double.parseDouble(temp[i]));
            	for(int i=allY.columns();i<temp.length;i++)
            		allX.set(line, i-allY.columns(), Double.parseDouble(temp[i]));
            	line++;
            }
            reader.close();
            
        } catch (IOException e) {
        	JOptionPane.showMessageDialog(null, "Error in reading the file!", "Error", JOptionPane.INFORMATION_MESSAGE);
        	MsgManager.Messages.errorMessage(e, "Error", "");
        } finally {
            if (reader != null) {
                try {
                    reader.close();                 
                } catch (IOException e1) {
                	JOptionPane.showMessageDialog(null, "Error in reading the file!", "Error", JOptionPane.INFORMATION_MESSAGE);
                	MsgManager.Messages.errorMessage(e1, "Error", "");
                }
            }
        }
    	
        return paras;
	}


	//from latent to orginal
	private int runMyGPDM(String filePath, String modelName, String outputName) {
		int exitVal = -1;
		
		Runtime rn = Runtime.getRuntime();
		Process p = null;
		try {
			//for standalone package
			String programPath = getClass().getProtectionDomain().getCodeSource().getLocation().getPath();	
								
			String os = System.getProperty("os.name");  
			if(os.toLowerCase().startsWith("win")){  
				programPath = programPath.replaceAll("^/", "");
				programPath = programPath.replaceAll("\\/", "\\\\");
				programPath = programPath.substring(0, programPath.lastIndexOf("\\")+1)+"GPDM\\win";
				programPath = programPath.replaceAll("%20"," ");
				p = rn.exec("cmd /c myGPLVM.exe -i "+filePath+"\\"+modelName+" -o "+filePath+"\\"+outputName,null, new File(programPath));
			}else if(os.toLowerCase().startsWith("linux")){ 
				p = rn.exec("./GPDM/linux/myGPLVM -i "+filePath+"/"+modelName+" -o "+filePath+"/"+outputName);
			}else if(os.toLowerCase().startsWith("mac")){ 
//				programPath = programPath.substring(0, programPath.lastIndexOf("/")+1)+"GPDM/mac";
//				programPath = programPath.replaceAll("%20","\" \"");
				p = rn.exec("./GPDM/mac/myGPLVM -i "+filePath+"/"+modelName+" -o "+filePath+"/"+outputName);
			}  
			
			
//			//for ide
//			String programPath = "E:\\netland\\workspace\\NetLand\\GPDM\\win";
//			p = rn.exec("cmd /c myGPLVM.exe -i "+filePath+"\\"+modelName+" -o "+filePath+"\\"+outputName,null, new File(programPath));
						
			
			//System.out.println("Run reverse mapping\n");
			checkForInterruption_process(p);
						
			exitVal = p.waitFor();
//			System.out.println("Process exitValue mygpdm: " + exitVal);
			
			
//			BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
//			String msg = null;
//			while ((msg = br.readLine()) != null) {
//				System.out.println(msg);
//			}
		} catch (Exception e) {
			JOptionPane.showMessageDialog(null, "Error in the execution of GPDM!", "Error", JOptionPane.INFORMATION_MESSAGE);
			MsgManager.Messages.errorMessage(e, "Error", "");
		}	
		return exitVal;
	}


	//run c++ GPDM
	public int runGPDM(String filePath, String filename, String outputModelName, int gpdmItsValue){	
		int exitVal = -1;

		Runtime rn = Runtime.getRuntime();
		Process p = null;
		try {
			//for standalone package
			String programPath = getClass().getProtectionDomain().getCodeSource().getLocation().getPath();	


			String os = System.getProperty("os.name");  		
			if(os.toLowerCase().startsWith("win")){   
				programPath = programPath.replaceAll("^/", "");
				programPath = programPath.replaceAll("\\/", "\\\\");	
				programPath = programPath.substring(0, programPath.lastIndexOf("\\")+1)+"GPDM\\win";
				programPath = programPath.replaceAll("%20"," ");
				p = rn.exec("cmd /C gplvm.exe -v 3 learn -L true -D rbf -# "+gpdmItsValue+" "+filePath+"\\"+filename+" "+filePath+"\\"+outputModelName,null, new File(programPath));
			}else if(os.toLowerCase().startsWith("linux")){ 
				p = rn.exec("./GPDM/linux/gplvm -v 3 learn -L true -D rbf -# "+gpdmItsValue+" "+filePath+"/"+filename+" "+filePath+"/"+outputModelName);
			}else if(os.toLowerCase().startsWith("mac")){ 
				//				programPath = programPath.substring(0, programPath.lastIndexOf("/")+1)+"GPDM/mac";
				//				programPath = programPath.replaceAll("%20","\" \"");
				p = rn.exec("./GPDM/mac/gplvm -v 3 learn -L true -D rbf -# "+gpdmItsValue+" "+filePath+"/"+filename+" "+filePath+"/"+outputModelName);
			}


//			//			//for ide
//			String programPath = "E:\\netland\\workspace\\NetLand\\GPDM\\win";			
//			p = rn.exec("cmd /C gplvm.exe -v 3 learn -L true -D rbf -# "+gpdmItsValue+" "+filePath+"\\"+filename+" "+filePath+"\\"+outputModelName,null, new File(programPath));
//
//			System.out.print("Run GPDM \n"); //+programPath+"\n"+filePath+"\n"+outputModelName+"\n"


			BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
			String msg = null;
			while ((msg = br.readLine()) != null) {
				System.out.println(msg);
				if( msg.equals("Press enter for more.") ){
					p.destroy();
					return -2;
//					JOptionPane.showMessageDialog(null, "Please try again.", "Error in execution of GPDM!", JOptionPane.INFORMATION_MESSAGE);
//					return exitVal;
				}
				checkForInterruption_process(p);
			}

			exitVal = p.waitFor();

		} catch (Exception e) {
			JOptionPane.showMessageDialog(null, "Error in the execution of GPDM!", "Error", JOptionPane.INFORMATION_MESSAGE);
			MsgManager.Messages.errorMessage(e, "Error", "");
		}
		
		return exitVal;	
	}
	
	//write SVML
	public int writeSVML(URL filename, ArrayList<DoubleMatrix2D> timeSeries, ArrayList<int[]> labeledSeries) throws IOException{
		
		//cannot take all data
		//int n1 = its/30; total 30 trajectories are selected
		int n1 = 10; //default 10 traj per attractor
		
		// Create a new file	
		FileWriter fw = new FileWriter(filename.getPath());   


		//define the num of traj for each attractor; thus we should sample enough items from each attractor!!!
		int[] nTrajPerAttr = new int[counts.length];
		int minCounts = 1000000;
		for(int i=0;i<counts.length;i++)
			if( minCounts>counts[i] )
				minCounts = counts[i];
		
		if( minCounts>n1 )
			for(int i=0;i<counts.length;i++)
				nTrajPerAttr[i] = n1;
		else
			for(int i=0;i<counts.length;i++)
				if( counts[i]<n1 )
					nTrajPerAttr[i] = counts[i];
				else
					nTrajPerAttr[i] = n1;

		
		int lines = 0;
		//write trajectories
		for(int i=0;i<counts.length;i++){	
			for(int jj=0;jj<nTrajPerAttr[i];jj++){
				DoubleMatrix2D tempX0 =  timeSeries.get(labeledSeries.get(i)[jj]);	
				int len = tempX0.rows();
				int interval = len<100?1:len/10;
				int numItem = (len-1)/interval+1;
				
//				//take the last 10
//				for(int j=tempX0.rows()-10;j<tempX0.rows();j+=1){ //rows: time length
//					String temp = "0";
//					for(int k=1;k<=tempX0.columns();k++)
//						temp += " "+k+":"+tempX0.get(j, k-1);
//					fw.write(temp+"\n");
//					lines++;
//				}
				
				for(int j=0;j<tempX0.rows();j+=interval){ //rows: time length
					String temp = "0";
					for(int k=1;k<=tempX0.columns();k++)
						temp += " "+k+":"+tempX0.get(j, k-1);
					fw.write(temp+"\n");
					lines++;
				}
			}
		}
		
		//write origAllY
		DoubleMatrix2D origAllY = new DenseDoubleMatrix2D(lines, grn_.getNodes().size());
		lines = 0;
		for(int i=0;i<counts.length;i++){	
			for(int jj=0;jj<nTrajPerAttr[i];jj++){
				DoubleMatrix2D tempX0 =  timeSeries.get(labeledSeries.get(i)[jj]);	
				int len = tempX0.rows();
				int interval = len<100?1:len/10;
				int numItem = (len-1)/interval+1;
				
//				//take the last 10
//				for(int j=tempX0.rows()-10;j<tempX0.rows();j+=1){ //rows: time length
//					for(int k=1;k<=tempX0.columns();k++)
//						origAllY.set(lines, k-1, tempX0.get(j, k-1));
//					lines++;
//				}
				
				
				for(int j=0;j<tempX0.rows();j+=interval){
					for(int k=1;k<=tempX0.columns();k++)
						origAllY.set(lines, k-1, tempX0.get(j, k-1));
					lines++;
				}
			}
		}
		grn_.setOrigAllY(origAllY);
		
		fw.close();   

		return lines;
	}
	
	
	
	private boolean checkAttractor(String[] focusGenes, ArrayList<DoubleMatrix2D> timeSeries, ArrayList<DoubleMatrix1D> theta){
		//discrete the final state
		int dimension = grn_.getNodes().size();
		
		//get gene index
		int[] focus_index = new int[focusGenes.length];
		for(int j=0;j<focusGenes.length;j++)
			for(int i=0;i<dimension;i++)
				if( grn_.getNode(i).getLabel().equals(focusGenes[j]) )
					focus_index[j] = i;
		
		//double check distances between attractors	
		String out =  calculateDistances(timeSeries, focus_index, dimension, theta);
		
		if( out.equals("ok") ){						
			return true;
		}
		
		return false;
	}
	
	
	private String calculateDistances(ArrayList<DoubleMatrix2D> timeSeries, int[] focus_index, int dimension, ArrayList<DoubleMatrix1D> theta) {		
		//solver equations
		List<String> solverResults_focusgenes = new ArrayList<String>(its);
		DoubleMatrix2D attractorTypes_focusgene = new DenseDoubleMatrix2D(its, focus_index.length);
		ArrayList<DoubleMatrix1D> attractorTypesAll = new ArrayList<DoubleMatrix1D>(its);
		
		//java.text.DecimalFormat df = new java.text.DecimalFormat("#.00");  
		for(int i=0;i<its;i++){		
			DoubleMatrix1D tempX0 =  timeSeries.get(i).viewRow(timeSeries.get(i).rows()-1);
		
			nonlinearEq a = new nonlinearEq(grn_);
			DoubleMatrix1D tempY = a.runSolver(tempX0,grn_);	
			if( tempY == null ) return "notStable";
			
			//judge if the stable state is far from the end position
			cern.jet.math.Functions F = cern.jet.math.Functions.functions;	
			double dis = tempX0.aggregate(tempY, F.plus, F.chain(F.square,F.minus));
			if( dis>500 ) return tempY.toString(); ////ad hoc	
			
			attractorTypesAll.add(tempY);

			String temp1 = "";
			for(int j=0;j<focus_index.length;j++){				
				double temp = Math.floor(100*tempY.get(focus_index[j]))/100;
				temp1 += temp+";" ;
				attractorTypes_focusgene.set(i, j, Math.abs(temp));
			}
			solverResults_focusgenes.add(temp1);	
		
		}
		
		//distance matrix
		double threshold = 0.1; //0.05 guojing
		ArrayList<Integer> output = calculateDisMatrix(attractorTypes_focusgene, threshold);
		
		Collections.sort(output);
		//remove i or j
		for(int i=output.size()-1;i>=0;i--){
			solverResults_focusgenes.remove((int)output.get(i));
			attractorTypes_focusgene = ColtUtils.deleteRow(attractorTypes_focusgene, output.get(i));
		}
		
		//remove duplicates
		List<String> uniqueList_focusgene = new ArrayList<String>(new HashSet<String>(solverResults_focusgenes));
		
		//calculate para
		sumPara = new DenseDoubleMatrix2D( uniqueList_focusgene.size(), dimension*2);
		counts = new int[uniqueList_focusgene.size()];
		labeledSeries = new ArrayList<int[]>(uniqueList_focusgene.size());
		sumPara.assign(0);
			
		int temp[][] = new int[counts.length][its];
		cern.jet.math.Functions F = cern.jet.math.Functions.functions;	
		for(int i=0;i<its;i++){
			DoubleMatrix1D tempX0 =  timeSeries.get(i).viewRow(timeSeries.get(i).rows()-1);
	
			//generate current vector
			DoubleMatrix1D temp1 = new DenseDoubleMatrix1D(focus_index.length);
			for(int j=0;j<focus_index.length;j++)
				temp1.set(j, Math.floor(100*tempX0.get(focus_index[j]))/100);
		
			//close to which attractor
			double[] tempSum = new double[sumPara.rows()]; 
			for(int k=0;k<uniqueList_focusgene.size();k++)
				tempSum[k] =  temp1.aggregate(attractorTypes_focusgene.viewRow(k), F.plus, F.chain(F.square,F.minus));
				
			
			//find the minimal distance
			int flag = -1; double minimal = 100000;
			for(int j=0;j<tempSum.length;j++)
				if(tempSum[j]<minimal){flag=j;minimal=tempSum[j];}
			
			counts[flag] += 1;
			temp[flag][counts[flag]-1] = i;
					
			for(int j=0;j<dimension;j++)
				sumPara.set(flag, j, sumPara.get(flag, j) + tempX0.get(j));
			
			for(int j=dimension;j<2*dimension;j++)
				sumPara.set(flag, j, sumPara.get(flag, j) + theta.get(i).get(j-dimension));
		}
		//-------------------
		
		for(int i=0;i<counts.length;i++)
			labeledSeries.add(temp[i]);
		
		for(int j=0;j<uniqueList_focusgene.size();j++)
			Transform.div(sumPara.viewRow(j), counts[j]);
		
		return "ok";
	}


	//return a set of [ minimum i j] with distance<threshold
	public static ArrayList<Integer> calculateDisMatrix(DoubleMatrix2D matrix, double threshold) {
		ArrayList<Integer> output = new ArrayList<Integer>();
		matrix = ColtUtils.transpose(matrix);
		DoubleMatrix2D a = Statistic.distance(matrix, Statistic.EUCLID);
				
		for(int i=0;i<a.rows()-1;i++)
			for(int j=i+1;j<a.columns();j++)
				if( a.get(i, j)<threshold ){
					if( !output.contains(j) )
						output.add(j);
				}
		
		return output;
	}


	private static double[] mean(double[] ds, double[] ds2) {
		double[] output = new double[ds.length];
		for(int i=0;i<ds.length;i++)
			output[i] = (ds[i] + ds2[i])/2;
		
		return output;
	}



	private void checkForInterruption() throws CancelException {	
		if (GnwSettings.getInstance().stopBenchmarkGeneration())
			throw new CancelException("Generation canceled!");
	}
	
	
	private void checkForInterruption_process(Process p) throws CancelException {	
		if (GnwSettings.getInstance().stopBenchmarkGeneration()){ 
			p.destroy();
			throw new CancelException("Generation canceled!");
		}
	}
	
	public static void mergeFiles(String outFile, String[] files) {  
        FileChannel outChannel = null;  
        int BUFSIZE = 1024 * 8;
        
        try {  
            outChannel = new FileOutputStream(outFile).getChannel();  
            for(String f : files){  
                FileChannel fc = new FileInputStream(f).getChannel();   
                ByteBuffer bb = ByteBuffer.allocate(BUFSIZE);  
                while(fc.read(bb) != -1){  
                    bb.flip();  
                    outChannel.write(bb);  
                    bb.clear();  
                }  
                fc.close();  
            }  
        } catch (IOException ioe) {  
        	JOptionPane.showMessageDialog(null, "Cannot merge two files!", "Error", JOptionPane.INFORMATION_MESSAGE);
        	MsgManager.Messages.errorMessage(ioe, "Error", "");
        } finally {  
            try {if (outChannel != null) {outChannel.close();}}
            catch (IOException ignore) {
            	JOptionPane.showMessageDialog(null, "Cannot merge two files!", "Error", JOptionPane.INFORMATION_MESSAGE);
            	MsgManager.Messages.errorMessage(ignore, "Error", "");
            }  
        }  
    }  
	
	
	
	
	
	
	private void calculatePara(ArrayList<DoubleMatrix2D> timeSeries, double max,ArrayList<DoubleMatrix1D> theta, boolean displayMethod) throws Exception{
		SDESolver deSolver_ = new SDESolver(grn_, true, 0);
		
//		//random start values
		deSolver_.setOutputDirectory(System.getProperty("user.dir"));
		deSolver_.setNumSeries(its); //foreach X0 runs once
		deSolver_.setMaxt(maxTime);
		deSolver_.setNumTimePoints(numTimePoints);
		deSolver_.setNoiseStrength(0);
		
		double dt_ = maxTime*1.0 / (numTimePoints - 1) ;
		deSolver_.setDt(dt_);
		
//		deSolver_.setIslandscape(true);
		deSolver_.setIslandscape(false);
		
		checkForInterruption();

		deSolver_.solveEquations_landscape(timeSeries,max,theta, displayMethod);
		checkForInterruption();
	}
	
	

	public double[][] getGridData() {
		return gridData;
	}


	
	public void setGridData(double[][] gridData) {
		this.gridData = gridData;
	}


	public String getOutputPath() {
		return outputPath;
	}


	public void setOutputPath(String outputPath) {
		this.outputPath = outputPath;
	}


	public boolean isStable() {
		return isStable;
	}


	public void setStable(boolean isStable) {
		this.isStable = isStable;
	}

	
}
