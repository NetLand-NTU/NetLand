package WindowGUI;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import org.math.plot.Plot2DPanel;
//import org.sf.surfaceplot.SurfaceCanvas;

import cern.colt.matrix.DoubleMatrix1D;
import cern.colt.matrix.DoubleMatrix2D;
import cern.colt.matrix.impl.DenseDoubleMatrix1D;
import ch.epfl.lis.gnw.Gene;
import ch.epfl.lis.gnw.GeneNetwork;
import ch.epfl.lis.gnwgui.DynamicalModelElement;
import ch.epfl.lis.gnwgui.NetworkElement;
import ch.epfl.lis.gnwgui.StructureElement;
import ch.epfl.lis.networks.Node;
import LandscapeDisplay.LandscapeSurfaceModel;
import LandscapeDisplay.LandscapeView;
import SurfacePlot.SurfaceCanvas;
import WidgetsTables.MultiTabs;
import WidgetsTables.ParameterTable;
import WidgetsTables.ReactionTable;
import WidgetsTables.RxnButtonRender;
import WidgetsTables.SpeciesTable;


public class WindowSimulationPanel extends JPanel{
	private static final long serialVersionUID = 1L;
	
	protected JPanel SimulationPanel;
	protected NetworkElement element;
	private LandscapeView landViewPanel;
	private JPanel bottomPanel;

	public WindowSimulationPanel(NetworkElement element) throws IOException{
		this.element = element;
		SimulationPanel = new JPanel();
		JPanel topPanel = new JPanel();
		JPanel bottomPanel = new JPanel();
		
		/** THE CONTENT OF LEFTPANEL **/ 		
		MultiTabs tabbsLeft = defineTabsLeft();
		tabbsLeft.getTabbedPane().setPreferredSize(new Dimension(300,1000));
		
		/** THE CONTENT OF RIGHTPANEL **/ 		
		MultiTabs tabbsRight = defineTabsRight();
		tabbsRight.getTabbedPane().setPreferredSize(new Dimension(800,1000));
		
		/** THE CONTENT OF BOTTOMPANEL **/
		SimulationBottomButton button1 = new SimulationBottomButton(1,new ImageIcon(getClass().getResource("rsc/buttons/load.png")), element);
		SimulationBottomButton button2 = new SimulationBottomButton(2,new ImageIcon(getClass().getResource("rsc/buttons/save.png")), element);
		SimulationBottomButton button3 = new SimulationBottomButton(3,new ImageIcon(getClass().getResource("rsc/buttons/traj.png")), element);
		SimulationBottomButton button4 = new SimulationBottomButton(4,new ImageIcon(getClass().getResource("rsc/buttons/land.png")), element);
		bottomPanel.add(button1.getButton());bottomPanel.add(button2.getButton());bottomPanel.add(button3.getButton());bottomPanel.add(button4.getButton());
		
		/**	SET LAYOUT **/
		topPanel.setLayout(new BoxLayout(topPanel, BoxLayout.X_AXIS));
		topPanel.setPreferredSize(new Dimension(1100,600));
		topPanel.add(tabbsLeft.getTabbedPane(), BorderLayout.CENTER);
		topPanel.add(tabbsRight.getTabbedPane(), BorderLayout.CENTER);
		
		SimulationPanel.setLayout(new BoxLayout(SimulationPanel, BoxLayout.Y_AXIS));
		SimulationPanel.add(topPanel);
		SimulationPanel.add(bottomPanel);
		
		/** SET FORMAT **/
		SimulationPanel.setBorder(BorderFactory.createEtchedBorder());
	}

	
	private MultiTabs defineTabsLeft(){
		//Tabs names
		ArrayList<String> LeftMultipleTabs = new ArrayList<String>();
		LeftMultipleTabs.add("Species");
		LeftMultipleTabs.add("Reactions");	
		LeftMultipleTabs.add("Parameters");
		LeftMultipleTabs.add("Info");

		//Components
		ArrayList<Component> c1 = new ArrayList<Component>();
	
		/** first Tab: Species **/
		c1.add(speciesTabb());

		/** second Tab: Reactions **/		
		c1.add(rxnsTabb());

		/** fourth Tab: Parameters **/
		c1.add(parametersTabb());
			
		/** fifth Tab: Parameters **/
		c1.add(infoTabb());
		
		MultiTabs tabbs = new MultiTabs(LeftMultipleTabs, c1); 	
		return tabbs;
	}


	private MultiTabs defineTabsRight() throws IOException{
		//Tabs names
		ArrayList<String> RightMultipleTabs = new ArrayList<String>();
		RightMultipleTabs.add("Landscape");
		RightMultipleTabs.add("Trajectories");	

		//Components
		ArrayList<Component> c1 = new ArrayList<Component>();
	
		/** first Tab: Landscape **/
		c1.add(landscapeTabb());

		/** second Tab: Trajectories **/		
		trajectoryTabb(c1);
			
		
		MultiTabs tabbs = new MultiTabs(RightMultipleTabs, c1); 	
		return tabbs;
	}
	

	

	/** define each tabb  **/
	private JPanel speciesTabb(){
		JPanel speciesPanel = new JPanel();
		String[] columnName = {"Name", "InitialValue"};
		new SpeciesTable(speciesPanel, columnName, element);
		
		return speciesPanel;
	}
	
	private JPanel rxnsTabb(){
		JPanel rxnPanel = new JPanel();
		String[] columnName = {"RxnId","TargetGene","Modifiers","Equation"};
		new ReactionTable(rxnPanel, columnName, element);

		return rxnPanel;
	}
	
	
	//------------------------------------------------------------------------------------
	//  landscape plot
	//------------------------------------------------------------------------------------
	private JPanel landscapeTabb() throws IOException{
		/** first Tab: Landscape **/
		//two comboboxes
		//generate geneList
		GeneNetwork grn = ((DynamicalModelElement) element).getGeneNetwork();
		String[] geneList = new String[grn.getNodes().size()];
		for(int i=0;i<grn.getNodes().size();i++)
			geneList[i] = grn.getNodes().get(i).getLabel();
		
		JPanel bottomPanel = new JPanel();
		
		//get displayMethod: probabilistic, gpdm, entropy
		String displayMethod = grn.getDisplayMethod();
		if( displayMethod.equals("probabilistic") ){
			//add two combo
			final JComboBox<String> combo1=new JComboBox<String>(geneList);
			combo1.setBorder(BorderFactory.createTitledBorder("X-axis"));
			final JComboBox<String> combo2=new JComboBox<String>(geneList);
			combo2.setSelectedIndex(0);
			combo2.setBorder(BorderFactory.createTitledBorder("Y-axis"));   

			//combo actions
			combo1.addActionListener(new ActionListener(){
				public void actionPerformed(ActionEvent e) {
					if(element instanceof StructureElement)
						JOptionPane.showMessageDialog(null, "Not dynamic Model!Run simulation first!", "Warning", JOptionPane.INFORMATION_MESSAGE);
					else if(element instanceof DynamicalModelElement){
						GeneNetwork grn = ((DynamicalModelElement)element).getGeneNetwork();

						if(grn.getCounts().length<=0){
//							JOptionPane.showMessageDialog(null, "Run LandscapeSimulation first!", "Warning", JOptionPane.INFORMATION_MESSAGE);
						}else{
							int indexX = combo1.getSelectedIndex();
							int indexY = combo2.getSelectedIndex();
							String axisX = (String) combo1.getSelectedItem();
							String axisY = (String) combo2.getSelectedItem();

							//get Jframe
							try {
								generateFigure(landViewPanel, grn, indexX, indexY, axisX, axisY);
							} catch (IOException e1) {
								System.out.print("Problem in setting combo1");
								e1.printStackTrace();
							}
						}
					}
				}
			});

			combo2.addActionListener(new ActionListener(){
				public void actionPerformed(ActionEvent e) {
					if(element instanceof StructureElement)
						JOptionPane.showMessageDialog(null, "Not dynamic Model!Run simulation first!", "Warning", JOptionPane.INFORMATION_MESSAGE);
					else if(element instanceof DynamicalModelElement){
						GeneNetwork grn = ((DynamicalModelElement)element).getGeneNetwork();

						if(grn.getCounts().length<=0){
//							JOptionPane.showMessageDialog(null, "Run LandscapeSimulation first!", "Warning", JOptionPane.INFORMATION_MESSAGE);
						}else{
							int indexX = combo1.getSelectedIndex();
							int indexY = combo2.getSelectedIndex();
							String axisX = (String) combo1.getSelectedItem();
							String axisY = (String) combo2.getSelectedItem();

							//get Jframe
							try {
								generateFigure(landViewPanel, grn, indexX, indexY, axisX, axisY);
							} catch (IOException e1) {
								System.out.print("Problem in setting combo2");
								e1.printStackTrace();
							}
						}
					}
				}
			});
		
			//LandscapeView
			landViewPanel = new LandscapeView();
//			landViewPanel.getCanvas().setSize(new Dimension(1000,400));
			
				
			if(grn.getCounts()==null){
				//				JOptionPane.showMessageDialog(null, "Run LandscapeSimulation first!", "Warning", JOptionPane.INFORMATION_MESSAGE);
			}else{
				int flag = 0;
				for(int k1=0;k1<grn.getCounts().length;k1++){
					if(grn.getCounts()[k1]==0){
						JOptionPane.showMessageDialog(null, "Attractor"+(k1+1)+" is not found!", "Error", JOptionPane.INFORMATION_MESSAGE);
						flag = 1;
					}
				}
			
				if( flag == 0 ){
					int indexX = combo1.getSelectedIndex();
					int indexY = combo2.getSelectedIndex();
					String axisX = (String) combo1.getSelectedItem();
					String axisY = (String) combo2.getSelectedItem();

					//get Jframe
					generateFigure(landViewPanel, grn, indexX, indexY, axisX, axisY);
				}
			}
				
		
			//set layout
			bottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.X_AXIS));
			bottomPanel.add(combo1);
			bottomPanel.add(combo2);
			
		}else if( displayMethod.equals("gpdm") ){
			//LandscapeView
			landViewPanel = new LandscapeView();
//			landViewPanel.getCanvas().setSize(new Dimension(1000,400));
			
				
			if(grn.getCounts()==null){
				//				JOptionPane.showMessageDialog(null, "Run LandscapeSimulation first!", "Warning", JOptionPane.INFORMATION_MESSAGE);
			}else{
				int flag = 0;
				for(int k1=0;k1<grn.getCounts().length;k1++){
					if(grn.getCounts()[k1]==0){
						JOptionPane.showMessageDialog(null, "Attractor"+(k1+1)+" is not found!", "Error", JOptionPane.INFORMATION_MESSAGE);
						flag = 1;
					}
				}
			
				if( flag == 0 ){
					//get Jframe
					generateFigure(landViewPanel, grn, -1, -1, "Component1", "Component2");
				}
			}
				
		
			//set layout
			bottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.X_AXIS));		
		}else if( displayMethod.equals("entropy") ){
			//LandscapeView
			landViewPanel = new LandscapeView();
//			landViewPanel.getCanvas().setSize(new Dimension(1000,400));
			
				
			if(grn.getCounts()==null){
				//				JOptionPane.showMessageDialog(null, "Run LandscapeSimulation first!", "Warning", JOptionPane.INFORMATION_MESSAGE);
			}else{
				int flag = 0;
				for(int k1=0;k1<grn.getCounts().length;k1++){
					if(grn.getCounts()[k1]==0){
						JOptionPane.showMessageDialog(null, "Attractor"+(k1+1)+" is not found!", "Error", JOptionPane.INFORMATION_MESSAGE);
						flag = 1;
					}
				}
			
				if( flag == 0 ){
					//get Jframe
					generateFigure(landViewPanel, grn, -2, -2, "Component1", "Component2");
				}
			}
				
		
			//set layout
			bottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.X_AXIS));	
		}

		
		JPanel LandPanel = new JPanel();
		LandPanel.setLayout(new GridBagLayout());
		NetLand.addComponent(LandPanel, landViewPanel.getCanvas(), 0, 0, 1, 1, GridBagConstraints.NORTHWEST, GridBagConstraints.BOTH, 0, 1);
		NetLand.addComponent(LandPanel, bottomPanel, 0, 1, 1, 1, GridBagConstraints.NORTHWEST, GridBagConstraints.BOTH, 1, 0);
	
		return LandPanel;
	}
		
	//generate figure of landscape by selected two genes
	private void generateFigure(LandscapeView landViewPanel, GeneNetwork grn_, int indexX, int indexY, String axisX, String axisY) throws IOException{
		SurfaceCanvas canvas = landViewPanel.getCanvas();	
		
		//get its
		int its = 0;
		
		for(int k1=0;k1<grn_.getCounts().length;k1++)
			its += grn_.getCounts()[k1];
	

		int n = grn_.getSize();
		double maxU = 0; double minU = 100000;
		
		
		//draw selection two genes
		if( indexX != -1 && indexX != -2 ){
			double stepSize = 0.1; 
			double[] x = LandscapeView.increment(0.0, stepSize, grn_.getMaxTime());
			double[] y = LandscapeView.increment(0.0, stepSize,  grn_.getMaxTime());
			
			double[][] gridData = new double[x.length][y.length];	
			
			for(int i=0;i<x.length;i++){
				for(int j=0;j<y.length;j++){
					double u = 0;
					//all types
					for(int k1=0;k1<grn_.getSumPara().rows();k1++){
						double u1 = Math.exp(-1.0*Math.pow((x[i]-grn_.getSumPara().get(k1, indexX)), 2)/2.0/grn_.getSumPara().get(k1, indexX+n))/grn_.getSumPara().get(k1, indexX+n)/Math.sqrt(2.0*Math.PI);
						double u2 = Math.exp(-1.0*Math.pow((y[j]-grn_.getSumPara().get(k1, indexY)), 2)/2.0/grn_.getSumPara().get(k1, indexY+n))/grn_.getSumPara().get(k1, indexY+n)/Math.sqrt(2.0*Math.PI);
						u += u1*u2*grn_.getCounts()[k1]/((double)its);
					}
					
					double up = -1.0*Math.log(u);
					if( up>100 )
						up=100;

					gridData[i][j] = up;


					if(gridData[i][j] >maxU)
						maxU = gridData[i][j] ;
					if(gridData[i][j] <minU)
						minU = gridData[i][j] ;
				}
			}
			
			//refresh figure
			canvas.destroyImage();
			
			LandscapeSurfaceModel model = new LandscapeSurfaceModel();
			model.setXAxisLabel(axisX);
			model.setYAxisLabel(axisY);
			model.setZAxisLabel("U");
			model.setXMax((float) x[x.length-1]);
			model.setXMin((float) x[0]);
			model.setYMax((float) y[y.length-1]);
			model.setYMin((float) y[0]);
			model.setZMax((float) maxU);
			model.setZMin((float) minU);
			model.setStepSizeX((float) stepSize);
			model.setStepSizeY((float) stepSize);
			model.setGridData(gridData);
			
			canvas.setModel(model);
			canvas.repaint();
		}
		//draw gpdm
		else if( indexX == -1 ){
			double[] x = LandscapeView.increment(grn_.getMinX(), (grn_.getMaxX()-grn_.getMinX())/grn_.getN(), grn_.getMaxX());
			double[] y = LandscapeView.increment(grn_.getMinY(), (grn_.getMaxY()-grn_.getMinY())/grn_.getN(), grn_.getMaxY());
			DoubleMatrix2D Yout = grn_.getAllY();
			
			double[][] gridData = new double[x.length][y.length];	
			
			int countNum = 0;
			for(int i=0;i<x.length;i++){
				for(int j=0;j<y.length;j++){
					DoubleMatrix1D currentY = Yout.viewRow(countNum);
					double u = 0;
					//all types
					for(int k1=0;k1<grn_.getSumPara().rows();k1++){
						double u1 = 1;
						for(int index=0;index<currentY.size();index++){
							currentY.set(index, Math.abs(currentY.get(index)));
							u1 *= Math.exp(-1.0*Math.pow((currentY.get(index)-grn_.getSumPara().get(k1, index)), 2)/2.0/grn_.getSumPara().get(k1, index+n))/grn_.getSumPara().get(k1, index+n)/Math.sqrt(2.0*Math.PI);
						}
						
						//in case that u1 is too large
						if( u1>100 )
							u1=100;
						u += u1*grn_.getCounts()[k1]/((double)its);
					}

					double up = -1.0*Math.log(u);
					if( up>100 )
						up=100;

					gridData[i][j] = up;


					if(gridData[i][j] >maxU)
						maxU = gridData[i][j] ;
					if(gridData[i][j] <minU)
						minU = gridData[i][j] ;
					
					countNum++;
				}
			}
			
			//refresh figure
			canvas.destroyImage();
			
			LandscapeSurfaceModel model = new LandscapeSurfaceModel();
			model.setXAxisLabel(axisX);
			model.setYAxisLabel(axisY);
			model.setZAxisLabel("U");
			float xmax = (float) ((int)(x[x.length-1]*100))/100;
			float xmin = (float) ((int) (x[0]*100))/100;
			
			float ymax = (float) ((int)(y[y.length-1]*100))/100;
			float ymin = (float) ((int) (y[0]*100))/100;
			
			float stepx = (float) (((int)((xmax-xmin)/grn_.getN()*100)))/100;
			float stepy = (float) (((int)((ymax-ymin)/grn_.getN()*100)))/100;
			
			xmax = xmin + stepx*grn_.getN();
			ymax = ymin + stepy*grn_.getN();
			
			double[] x1 = LandscapeView.increment(xmin, stepx, xmax);
			double[] y1 = LandscapeView.increment(ymin, stepy, ymax);
 			
			
			model.setXMax((float) x1[x1.length-1]);			
			model.setXMin((float) x1[0]);		
			model.setYMax((float) y1[y1.length-1]);		
			model.setYMin((float) y1[0]);
			maxU = (float) ((int) maxU*100)/100;
			model.setZMax((float) maxU);
			minU = (float) ((int) minU*100)/100;
			model.setZMin((float) minU);
	
			model.setStepSizeX(stepx);
			model.setStepSizeY(stepy);
			model.setGridData(gridData);
			
			canvas.setModel(model);
			canvas.repaint();
			
		}//end of else gpdm
		else{ //display of entropy
			double[] x = LandscapeView.increment(grn_.getMinX(), (grn_.getMaxX()-grn_.getMinX())/grn_.getN(), grn_.getMaxX());
			double[] y = LandscapeView.increment(grn_.getMinY(), (grn_.getMaxY()-grn_.getMinY())/grn_.getN(), grn_.getMaxY());
			DoubleMatrix2D Yout = grn_.getAllY();
			
			//calculate the network entropy
			//write entropy
			//input file
			String filename = "temp_"+System.currentTimeMillis();
			String temppath = System.getProperty("java.io.tmpdir");
			File f = new File(temppath);
			File fTemp = File.createTempFile(filename, ".entropy_input", f);
				
			URL url = fTemp.toURI().toURL();
			int numYorig = writeEntropy(url,Yout);		

			//output file
			String outputModelName = "temp_"+System.currentTimeMillis();
			File fout = new File(temppath);
			File fTempout = File.createTempFile(outputModelName, ".entropy_output", fout);

			//run GPDM
			runNetworkEntropy(temppath,fTemp.getName(),fTempout.getName());

			//read output file
			double[][] gridData = new double[x.length][y.length];	
			readEntropyOutput(fTempout, gridData, x.length);

			//draw landscape
			for(int i=0;i<x.length;i++){
				for(int j=0;j<y.length;j++){
					if(gridData[i][j] >maxU)
						maxU = gridData[i][j] ;
					if(gridData[i][j] <minU)
						minU = gridData[i][j] ;
				}
			}


			//refresh figure
			canvas.destroyImage();

			LandscapeSurfaceModel model = new LandscapeSurfaceModel();
			model.setXAxisLabel(axisX);
			model.setYAxisLabel(axisY);
			model.setZAxisLabel("U");
			float xmax = (float) ((int)(x[x.length-1]*100))/100;
			float xmin = (float) ((int) (x[0]*100))/100;
			
			float ymax = (float) ((int)(y[y.length-1]*100))/100;
			float ymin = (float) ((int) (y[0]*100))/100;
			
			float stepx = (float) (((int)((xmax-xmin)/grn_.getN()*10000)-1))/10000;
			float stepy = (float) (((int)((ymax-ymin)/grn_.getN()*10000)-1))/10000;
			
			xmax = xmin + stepx*grn_.getN();
			ymax = ymin + stepy*grn_.getN();
			
			double[] x1 = LandscapeView.increment(xmin, stepx, xmax);
			double[] y1 = LandscapeView.increment(ymin, stepy, ymax);
 			
			
			model.setXMax((float) x1[x1.length-1]);			
			model.setXMin((float) x1[0]);		
			model.setYMax((float) y1[y1.length-1]);		
			model.setYMin((float) y1[0]);
			maxU = (float) ((int) maxU*100)/100;
			model.setZMax((float) maxU);
			minU = (float) ((int) minU*100)/100;
			model.setZMin((float) minU);
	
			model.setStepSizeX(stepx);
			model.setStepSizeY(stepy);
			model.setGridData(gridData);

			canvas.setModel(model);
			canvas.repaint();
			
			fTemp.deleteOnExit();
			fTempout.deleteOnExit();
		}
			
		
	}
	
	
	
	private void readEntropyOutput(File fTempnew, double[][] gridData, int npoints) {		
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new FileReader(fTempnew));
            String tempString = null;

            tempString = reader.readLine();
            String temp[] = tempString.split(" ");
            
            int counts = 0;
            for(int i=0;i<npoints;i++)
            	for(int j=0;j<npoints;j++){
            		if( temp[counts].equals("nan") ){
            			if( counts == 0 )
            				temp[counts] = "0";
            			else
            				temp[counts] = temp[counts-1];
            		}else
            			gridData[i][j] = Double.parseDouble(temp[counts]);
            		counts++;
            	}
            
            
            while ((tempString = reader.readLine()) != null) {
            }
            
            reader.close();
            
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                    
                } catch (IOException e1) {
                }
            }
        }
    	
	}


	private void runNetworkEntropy(String temppath, String inputfile, String outputfile) {
		Runtime rn = Runtime.getRuntime();
		Process p = null;
		try {
			File f = new File("Entropy");
			String programPath = f.getAbsolutePath();
			//String programPath = getClass().getResource("GPDM/gplvm.exe").toString();
			//programPath = programPath.replaceAll("file:/", "");
			//String temppath = new File("/").getAbsolutePath();
           // System.out.print(programPath) ;
            
			
			p = rn.exec("cmd /c entropy.exe -i "+temppath+"\\"+inputfile+" -o "+temppath+"\\"+outputfile,null, new File(programPath));
			
			
			BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
			String msg = null;
			while ((msg = br.readLine()) != null) {
				System.out.println(msg);
			}
			
			int exitVal = p.waitFor();
			System.out.println("Process exitValue: " + exitVal);
			
		} catch (Exception e) {
			System.out.println("Error exec entropy!");
		}	
		
	}


	private int writeEntropy(URL filename, DoubleMatrix2D yout) {
		// Create a new SBMLDocument object, using SBML Level 1 Version 2.		
		try {
			FileWriter fw = new FileWriter(filename.getPath());
			
			fw.write(yout.rows()+" "+yout.columns()+"\n");

			//write trajectories rows*cols		
			for(int i=0;i<yout.rows();i++){
				fw.write(""+yout.get(i, 0));
				for(int j=1;j<yout.columns();j++)
					fw.write(" "+yout.get(i, j));
				fw.write("\n");
			}
			
			//write connectivity matrix
			GeneNetwork grn = ((DynamicalModelElement)element).getGeneNetwork();
			int ngenes = grn.getNodes().size();
			ArrayList<Node> nodes = grn.getNodes();
			DoubleMatrix1D connMatrix = new DenseDoubleMatrix1D(ngenes*ngenes);
			int counts = 0;
			//set content 
			for(int i=0;i<ngenes;i++){
				Gene targetGene = (Gene) grn.getNode(i);
				
				ArrayList<Gene> inputGenes = ((Gene) targetGene).getInputGenes();
				for(int j=0;j<ngenes;j++){
					int flag = 0;
					for(int k=0;k<inputGenes.size();k++)
						if( inputGenes.get(k).getLabel().equals(nodes.get(j).getLabel()) ){
							connMatrix.set(counts, 1);
							flag = 1;
						}
					if( flag == 0 )
						connMatrix.set(counts, 0);
					counts++;
				}
			}//end of for
			
			//write to file
			fw.write(connMatrix.get(0)+"");
			for(int i=1;i<counts;i++)
				fw.write(" "+connMatrix.get(i));
			fw.write("\n");
			
			fw.close(); 
		} catch (IOException e1) {
			System.out.print("Cannot load the entropy_input file\n");
			e1.printStackTrace();
		}   


		return 0;
	}


	private JTextArea infoTabb(){
		String infoContent = "Summary\nBasic Info\n";
		
		GeneNetwork grn = ((DynamicalModelElement)element).getGeneNetwork();

		if(grn.getCounts()!=null || grn.getSumPara()!=null){
			int[] counts = grn.getCounts();
			DoubleMatrix2D sumPara = grn.getSumPara();

			infoContent += "Attractor Types: \n";

			for(int i=0;i<sumPara.rows();i++){
				infoContent += sumPara.viewRow(i).toString() + "\tnum: " + counts[i] + "\n";
				infoContent += "\n\n";
			}
		}

		
		JTextArea info = new JTextArea(infoContent);
		info.setEditable(false); info.setLineWrap(true); info.setWrapStyleWord(true);
		
		return info;
	}
	
	
	private JPanel parametersTabb(){
		String[] columnName1 = {"Name", "Value"};
		JPanel tablePanel1 = new JPanel();
		new ParameterTable(tablePanel1, columnName1, element);
		return tablePanel1;
	}

	
	private void trajectoryTabb(ArrayList<Component> c1){
		//judge if converged
		final JLabel convergePanel = new JLabel();
		
		
		final Plot2DPanel plot = new Plot2DPanel();
        plot.addLegend("SOUTH");
        plot.setAxisLabel(0, "t");
        plot.setAxisLabel(1, "ExpressionValue");
        plot.setPreferredSize(new Dimension(440,390));
		
		
        if (element instanceof StructureElement) {
        	double[] x = { 1, 2, 3, 4, 5, 6 };
        	double[] y = { 0, 0, 0, 0, 0, 0 };
        	
        	plot.addLinePlot("my plot", x, y);	
        	c1.add(plot);
		} else if (element instanceof DynamicalModelElement) {
			GeneNetwork grn = ((DynamicalModelElement)element).getGeneNetwork();
			final ArrayList<DoubleMatrix2D> timeSeries_ = grn.getTimeSeries();
	    	final ArrayList<DoubleMatrix1D> timeScale_ = grn.getTimeScale();
   	
	    	//display initial values
	    	if(timeSeries_.size()==0){   			        
	    		DoubleMatrix1D x0 = grn.getInitialState();
	    		for(int i=0;i<x0.size();i++){
	    			double[] x = { 1, 2, 3, 4, 5, 6 };
	                double[] y = new double[x.length];
	                for(int j=0;j<x.length;j++)
	                	y[j] = 0;    
	                plot.addLinePlot(((DynamicalModelElement) element).getGeneNetwork().getNode(i).getLabel(), x, y);	
	    		}
	    		c1.add(plot);
	    	}else{
	    		//display multiple time series
	    		//combobox
	    		//generate time series List
	    		String[] timeSeriesList = new String[timeSeries_.size()];

	    		for(int i=0;i<timeSeries_.size();i++)
	    			timeSeriesList[i] = Integer.toString(i);
	    		
	    		JLabel selectPanelName = new JLabel("Select trajectory: ");
	    		JPanel selectPanel = new JPanel();
	    		selectPanel.setPreferredSize(new Dimension(1000,10));
	    		final JComboBox<String> combo=new JComboBox<String>(timeSeriesList);	    			    		
  		
	    		//view window
	    		final JPanel trajectoryViewPanel = new JPanel();
	    		trajectoryViewPanel.setPreferredSize(new Dimension(990,500));
	    			    		 		
	    		plot.setPreferredSize(new Dimension(990,500));
	    		double[] t = timeScale_.get(0).toArray();
	    		for(int k=0;k<timeSeries_.get(0).columns();k++){
	    			double[] y = timeSeries_.get(0).viewColumn(k).toArray();
	    			plot.addLinePlot(((DynamicalModelElement) element).getGeneNetwork().getNode(k).getLabel(), t, y);	
	    			convergePanel.setText("isConverged: "+converged(timeSeries_.get(0)));
	    		}		
	    		
	    		//combobox action	    		
	    		combo.addActionListener(new ActionListener() {
	    			public void actionPerformed(ActionEvent e) {
	    				int row = combo.getSelectedIndex();				

	    				plot.removeAllPlots();
	    				
	    				double[] t = timeScale_.get(row).toArray();
	    	    		for(int k=0;k<timeSeries_.get(row).columns();k++){
	    	    			double[] y = timeSeries_.get(row).viewColumn(k).toArray();
	    	    			plot.addLinePlot(((DynamicalModelElement) element).getGeneNetwork().getNode(k).getLabel(), t, y);
	    	    			convergePanel.setText("isConverged: "+converged(timeSeries_.get(0)));
	    	    		}	
	  	    	    		
	    	    		trajectoryViewPanel.repaint();
	    	    		trajectoryViewPanel.setVisible(true);
	    			}			 
	    		});
	    			    		
	    		
	    		selectPanel.setLayout(new BoxLayout(selectPanel, BoxLayout.X_AXIS)); 
	    		selectPanel.add(selectPanelName);
	    		selectPanel.add(combo);
	    		trajectoryViewPanel.add(plot);
	    		
	    		//set layout
	    		JPanel trajectoryPanel = new JPanel();
	    		trajectoryPanel.setLayout(new GridBagLayout());
	    		NetLand.addComponent(trajectoryPanel, trajectoryViewPanel, 0, 0, 1, 1, GridBagConstraints.NORTHWEST, GridBagConstraints.BOTH, 0, 1);
	    		NetLand.addComponent(trajectoryPanel, selectPanel, 0, 1, 1, 1, GridBagConstraints.NORTHWEST, GridBagConstraints.BOTH, 1, 0);
	    		NetLand.addComponent(trajectoryPanel, convergePanel, 0, 2, 1, 1, GridBagConstraints.NORTHWEST, GridBagConstraints.BOTH, 1, 0);
	    		
	    		c1.add(trajectoryPanel);
	    	}
		}
	}
	
	
	/** 
	 * Implements the method gsl_multiroot_test_delta() of GSL:
	 * This function tests for the convergence of the sequence by comparing the last step dx
	 * with the absolute error epsabs and relative error epsrel to the current position x.
	 * The test returns true if the following condition is achieved:
     * 		|dx_i| < epsabs + epsrel |x_i|
     * for each component of x and returns false otherwise.
	 */
	public String converged(DoubleMatrix2D x) {	 
		double absolutePrecision_ = 0.00001;
		double relativePrecision_ = 0.001;
		
		int totalTime = x.rows();
		int genes = x.columns();
		DoubleMatrix1D previousState_ = x.viewRow(totalTime-2);
		DoubleMatrix1D state_ = x.viewRow(totalTime-1);
		
		for (int i=0; i<genes; i++) {	
			double dxy = Math.abs(previousState_.get(i) - state_.get(i)); 
			
			if (dxy > absolutePrecision_ + relativePrecision_*Math.abs(state_.get(i))) {
				return "Not converged";
			}
		}
		return "Converged";
	}
	

//	public void setInfoContent(String infoContent){ this.infoContent = infoContent; }
	public JPanel getSimulationPanel(){ return SimulationPanel; }
	public void setElement(NetworkElement element){ this.element = element; }
	public LandscapeView getLandViewPanel(){ return landViewPanel; }


	public JPanel getBottomPanel() {
		return bottomPanel;
	}


	public void setBottomPanel(JPanel bottomPanel) {
		this.bottomPanel = bottomPanel;
	}
}


