package LandscapeAnimation;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.MouseEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Random;

import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ButtonGroup;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JDialog;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import javax.swing.JScrollPane;
import javax.swing.JSplitPane;
import javax.swing.JTable;

import org.jzy3d.chart.ContourChart;
import org.jzy3d.chart.controllers.mouse.camera.AWTCameraMouseController;
import org.jzy3d.colors.Color;
import org.jzy3d.colors.ColorMapper;
import org.jzy3d.colors.colormaps.ColorMapRainbow;
import org.jzy3d.contour.DefaultContourColoringPolicy;
import org.jzy3d.contour.MapperContourPictureGenerator;
import org.jzy3d.maths.BoundingBox3d;
import org.jzy3d.maths.Coord3d;
import org.jzy3d.maths.Range;
import org.jzy3d.maths.TicToc;
import org.jzy3d.maths.Utils;
import org.jzy3d.picking.IObjectPickedListener;
import org.jzy3d.picking.PickingSupport;
import org.jzy3d.plot3d.builder.Builder;
import org.jzy3d.plot3d.builder.Mapper;
import org.jzy3d.plot3d.primitives.AbstractDrawable;
import org.jzy3d.plot3d.primitives.LineStrip;
import org.jzy3d.plot3d.primitives.Point;
import org.jzy3d.plot3d.primitives.Shape;
import org.jzy3d.plot3d.primitives.axes.ContourAxeBox;
import org.jzy3d.plot3d.rendering.canvas.ICanvas;
import org.jzy3d.plot3d.rendering.canvas.Quality;
import org.jzy3d.plot3d.rendering.legends.colorbars.AWTColorbarLegend;
import org.jzy3d.plot3d.rendering.view.Renderer2d;

import LandscapeDisplay.SDESolver;
import MsgManager.Messages;
import WidgetsTables.SpeciesTable;

import cern.colt.matrix.DoubleFactory2D;
import cern.colt.matrix.DoubleMatrix1D;
import cern.colt.matrix.DoubleMatrix2D;
import cern.colt.matrix.impl.DenseDoubleMatrix1D;
import cern.colt.matrix.impl.DenseDoubleMatrix2D;
import ch.epfl.lis.gnw.CancelException;
import ch.epfl.lis.gnw.GeneNetwork;
import ch.epfl.lis.gnw.GnwSettings;










public class CopyOfLandscapePanel2 extends JFrame{	
	/** DATA **/
	private GeneNetwork grn_;
	private boolean isProbabilisticLandscape;

	private double[] landpointsX;
	private double[] landpointsY;
	private double[][] landpointsZ;
	private double[] trajDataInLandX;
	private double[] trajDataInLandY;
	private double[] trajDataInLandZ;

	private double[] time;
	private double[][] trajDataY;

	public int nGenes;
	private String[] geneNames;
	private ArrayList<Integer> selectedGenes = new ArrayList<Integer>();



	/** GUI components **/
	private JSplitPane splitPane;	
	private JPanel landscapePanel;
	private JPanel contourTablePanel;
	private JPanel controlPanel;

	private JPanel trajLinePanel;
	private JPanel trajTablePanel;
	private JPanel trajControlPanel;

	private JPanel comboPanel;


	private JTable dataTable;

	private JCheckBox[] checkBoxes;
	private JComboBox<String> combo1;
	private JComboBox<String> combo2;

	private MultipleLineGraph linegraph;
	private TrajDataTable trajDataTableItem; 


	private Shape surface;
	private ContourChart landscapeChart;

	private String fpsText;
	protected myThread t;
	private List<Coord3d> coords;
	private List<MyPickablePoint> points;
	private JButton contourButton;
	private BoundingBox3d bounds;
	private Color[] colors;
	private JRadioButton radio_set;
	private ColorMapper myColorMapper;

	//	public static void main(String args[]) {
	//		LandscapePanel onea = new LandscapePanel();		
	//	}

	public CopyOfLandscapePanel2(GeneNetwork grn, boolean displayMethod){
		//initial data
		grn_ = grn;
		isProbabilisticLandscape = displayMethod;

		nGenes = grn.getNodes().size();
		geneNames = new String[nGenes];
		for(int i=0;i<nGenes;i++)
			geneNames[i] = grn.getNodes().get(i).getLabel();


		if( isProbabilisticLandscape )
			updateDataProLand(0,0);
		else
			updateDataGPDMLand();	

		//plot
		createDrawingChart();
		if( isProbabilisticLandscape ){
			landscapeChart.getAxeLayout().setXAxeLabel(geneNames[0]);
			landscapeChart.getAxeLayout().setYAxeLabel(geneNames[0]);
		}else{
			landscapeChart.getAxeLayout().setXAxeLabel("Component 1");
			landscapeChart.getAxeLayout().setYAxeLabel("Component 2");
		}

		GUI();
	}

	public double[] increment(double d, double e, double f) {
		int length = (int) (Math.rint((f-d)/e)+1);
		double[] temp=new double[length];
		for (int i = 0; i < temp.length; i++){
			temp[i]=(Math.rint(1000*(d+e*i)))/1000.0;        		
		}
		return temp;
	}

	public void GUI(){
		//drawing
		landscapePanel = new JPanel();
		contourTablePanel = new JPanel();
		controlPanel = new JPanel();
		trajControlPanel = new JPanel();
		trajLinePanel = new JPanel();
		trajTablePanel = new JPanel();
		comboPanel = new JPanel();

		JPanel rightPanel = new JPanel();
		JPanel leftPanel = new JPanel();

		splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, leftPanel, rightPanel);
		splitPane.setDividerLocation(2.0 / 3.0);  
		splitPane.setResizeWeight(0.5);
		splitPane.setOneTouchExpandable(true);
		splitPane.setContinuousLayout(true);


		setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
		setTitle("Landscape");
		landscapePanel.setLayout(new java.awt.BorderLayout());
		landscapePanel.setPreferredSize(new java.awt.Dimension(700, 550));
		landscapePanel.setBackground(java.awt.Color.WHITE);
		comboPanel.setPreferredSize(new java.awt.Dimension(700, 50));
		contourTablePanel.setPreferredSize(new java.awt.Dimension(200, 500));
		contourTablePanel.setLayout(new java.awt.BorderLayout());
		trajLinePanel.setPreferredSize(new java.awt.Dimension(200, 250));
		trajLinePanel.setLayout(new java.awt.BorderLayout());
		controlPanel.setLayout(new java.awt.BorderLayout());
		controlPanel.setPreferredSize(new java.awt.Dimension(200, 100));
		trajTablePanel.setLayout(new BoxLayout(trajTablePanel, BoxLayout.Y_AXIS));
		trajTablePanel.setPreferredSize(new java.awt.Dimension(200, 200));
		trajControlPanel.setLayout(new BoxLayout(trajControlPanel, BoxLayout.Y_AXIS));
		trajControlPanel.setPreferredSize(new java.awt.Dimension(200, 100)); 
		rightPanel.setPreferredSize(new java.awt.Dimension(200, 600));
		leftPanel.setPreferredSize(new java.awt.Dimension(700, 600));


		trajLinePanel.setVisible(false);
		trajControlPanel.setVisible(false);
		trajTablePanel.setVisible(false);
		BoxLayout layout=new BoxLayout(rightPanel, BoxLayout.Y_AXIS); 
		rightPanel.setLayout(layout);
		rightPanel.add(controlPanel);
		rightPanel.add(trajControlPanel);
		rightPanel.add(contourTablePanel);
		rightPanel.add(trajTablePanel);
		rightPanel.add(trajLinePanel);


		layout = new BoxLayout(leftPanel, BoxLayout.Y_AXIS); 
		leftPanel.setLayout(layout);		
		leftPanel.add(landscapePanel);
		leftPanel.add(comboPanel);
		

		//draw landscapePanel
		plotLandscapePanel();

		//draw comboPanel
		plotComboPanel();
		if( isProbabilisticLandscape )
			comboPanel.setVisible(true);
		else
			comboPanel.setVisible(false);



		//draw controlPanel
		plotControlPanel();

		//draw trajPanel
		plotTrajPanel();		

		//draw contourTablePanel
		DataTable atable = new DataTable(contourTablePanel, landpointsX, landpointsY, landpointsZ, grn_, isProbabilisticLandscape, radio_set, points, myColorMapper);
		dataTable = atable.getTable();

		//initial checkboxes
		checkBoxes = new JCheckBox[geneNames.length];

		setPreferredSize(new Dimension(1200, 600));
		getContentPane().add(splitPane, BorderLayout.CENTER);
		pack();
		setVisible(true);
		setResizable(false);		
		setLocationRelativeTo(null);  
		setDefaultCloseOperation(DISPOSE_ON_CLOSE);	
	}

	private void plotComboPanel() {
		combo1=new JComboBox<String>(geneNames);
		combo1.setBorder(BorderFactory.createTitledBorder("X-axis"));
		combo1.setLightWeightPopupEnabled(false);
		combo2=new JComboBox<String>(geneNames);
		combo2.setSelectedIndex(0);
		combo2.setBorder(BorderFactory.createTitledBorder("Y-axis"));   
		combo2.setLightWeightPopupEnabled(false);

		//combo actions
		combo1.addActionListener(new ActionListener(){
			public void actionPerformed(ActionEvent e) {
				int indexX = combo1.getSelectedIndex();
				int indexY = combo2.getSelectedIndex();
				String axisX = (String) combo1.getSelectedItem();
				String axisY = (String) combo2.getSelectedItem();

				updateFrameWithComboSelection(indexX, indexY, axisX, axisY);
			}
		});

		combo2.addActionListener(new ActionListener(){
			public void actionPerformed(ActionEvent e) {
				int indexX = combo1.getSelectedIndex();
				int indexY = combo2.getSelectedIndex();
				String axisX = (String) combo1.getSelectedItem();
				String axisY = (String) combo2.getSelectedItem();

				updateFrameWithComboSelection(indexX, indexY, axisX, axisY);
			}
		});

		//set layout
		comboPanel.setLayout(new BoxLayout(comboPanel, BoxLayout.X_AXIS));
		combo1.setBackground(java.awt.Color.WHITE);
		combo2.setBackground(java.awt.Color.WHITE);
		comboPanel.add(combo1);
		comboPanel.add(combo2);
	}


	protected void updateFrameWithComboSelection(int indexX, int indexY, String axisX, String axisY) {
		//draw probabilistic landscape
		if( isProbabilisticLandscape ){
			updateDataProLand(indexX, indexY);

			//refresh landscape figure
			updateDrawingChart();
			landscapeChart.getAxeLayout().setXAxeLabel(axisX);
			landscapeChart.getAxeLayout().setYAxeLabel(axisY);

			//refresh dataTable
			contourTablePanel.updateUI();
			
			//remove contour
			landscapeChart.getView().setBoundManual(bounds);
			contourButton.setText("Show the contour map");
			ContourAxeBox newcab = new ContourAxeBox(bounds); 
			landscapeChart.getView().setAxe(newcab);
		}
		//draw gpdm
		else if( indexX == -1 ){			
			updateDataGPDMLand();	
			comboPanel.setVisible(false);

			//refresh landscape figure
			updateDrawingChart();
			landscapeChart.getAxeLayout().setXAxeLabel("Component 1");
			landscapeChart.getAxeLayout().setYAxeLabel("Component 2");

			//refresh dataTable
			contourTablePanel.updateUI();	

			//remove contour
			landscapeChart.getView().setBoundManual(bounds);
			contourButton.setText("Show the contour map");
			ContourAxeBox newcab = new ContourAxeBox(bounds); 
			landscapeChart.getView().setAxe(newcab);
		}//end of else gpdm	

	}

	private void updateDataGPDMLand() {
		landpointsX = increment(grn_.getMinX(), (grn_.getMaxX()-grn_.getMinX())/grn_.getN(), grn_.getMaxX());
		landpointsY = increment(grn_.getMinY(), (grn_.getMaxY()-grn_.getMinY())/grn_.getN(), grn_.getMaxY());
		landpointsZ = new double[landpointsX.length][landpointsY.length];	
		DoubleMatrix2D Yout = grn_.getAllY();


		double maxU = 0; double minU = 100000;
		for(int i=0;i<landpointsX.length;i++){
			for(int j=0;j<landpointsY.length;j++){
				landpointsZ[i][j] = computeOnePointGPDM(Yout, i, j);

				if(landpointsZ[i][j] >maxU)
					maxU = landpointsZ[i][j] ;
				if(landpointsZ[i][j] <minU)
					minU = landpointsZ[i][j] ;

			}
		}

		//set data output
		grn_.setGridData(new DenseDoubleMatrix2D(landpointsZ));
		grn_.setMinX(getMin(landpointsX));
		grn_.setMaxX(getMax(landpointsX));
		grn_.setMinY(getMin(landpointsY));
		grn_.setMaxY(getMax(landpointsY));
	}


	private double computeOnePointGPDM(DoubleMatrix2D Yout, int xIndex, int yIndex) {
		DoubleMatrix1D currentY = Yout.viewRow(xIndex*landpointsX.length+yIndex);
		double u = 0;
		//all types
		for(int k1=0;k1<grn_.getSumPara().rows();k1++){
			double u1 = 1;
			for(int index=0;index<currentY.size();index++){
				currentY.set(index, Math.abs(currentY.get(index)));
				u1 *= Math.exp(-1.0*Math.pow((currentY.get(index)-grn_.getSumPara().get(k1, index)), 2)/2.0/grn_.getSumPara().get(k1, index+nGenes))/grn_.getSumPara().get(k1, index+nGenes)/Math.sqrt(2.0*Math.PI);
			}

			//in case that u1 is too large
			if( u1>100 )
				u1=100;
			u += u1*grn_.getCounts()[k1]/((double)grn_.getLand_itsValue());
		}

		double up = -1.0*Math.log(u);
		if( up>100 )
			up=100;

		return up;
	}

	private void updateDrawingChart() {
		clearAllinChart();

		//generate points
		coords = getSurf();
		
		/**        surface           **/
		createSurface();

		//generate pickable points
		createPickablePoints();

		//add new objects
		landscapeChart.getScene().getGraph().add(surface);
		landscapeChart.getScene().getGraph().add( points );
	}


	private void updateDataProLand(int indexX, int indexY) {
		landpointsX = increment(0.0, 0.1, grn_.getLand_maxExpValue());
		landpointsY = increment(0.0, 0.1, grn_.getLand_maxExpValue());			
		landpointsZ = new double[landpointsX.length][landpointsY.length];;

		calculateLandU(landpointsX, landpointsX, landpointsZ, indexX, indexY);

		//update contourTable
		if( contourTablePanel != null ){
			contourTablePanel.removeAll();
			DataTable atable = new DataTable(contourTablePanel, landpointsX, landpointsY, landpointsZ, grn_, isProbabilisticLandscape, radio_set, points, myColorMapper);
			dataTable = atable.getTable();
		}
		
		//set data output
		grn_.setGridData(new DenseDoubleMatrix2D(landpointsZ));
		grn_.setMinX(getMin(landpointsX));
		grn_.setMaxX(getMax(landpointsX));
		grn_.setMinY(getMin(landpointsY));
		grn_.setMaxY(getMax(landpointsY));
	}



	private void calculateLandU(double[] landpointsX, double[] landpointsY, double[][] landpointsZ, int indexX, int indexY) {
		double its = 0;
		for(int i=0;i<grn_.getCounts().length;i++)
			its += grn_.getCounts()[i];

		double maxU = 0; double minU = 100000;
		for(int i=0;i<landpointsX.length;i++){
			for(int j=0;j<landpointsY.length;j++){
				double u = 0;
				//all types
				for(int k1=0;k1<grn_.getSumPara().rows();k1++){
					double u1 = Math.exp(-1.0*Math.pow((landpointsX[i]-grn_.getSumPara().get(k1, indexX)), 2)/2.0/grn_.getSumPara().get(k1, indexX+nGenes))/grn_.getSumPara().get(k1, indexX+nGenes)/Math.sqrt(2.0*Math.PI);
					double u2 = Math.exp(-1.0*Math.pow((landpointsY[j]-grn_.getSumPara().get(k1, indexY)), 2)/2.0/grn_.getSumPara().get(k1, indexY+nGenes))/grn_.getSumPara().get(k1, indexY+nGenes)/Math.sqrt(2.0*Math.PI);
					u += u1*u2*grn_.getCounts()[k1]/its;
				}

				double up = -1.0*Math.log(u);
				if( up>100 )
					up=100;

				landpointsZ[i][j] = up;


				if(landpointsZ[i][j] >maxU)
					maxU = landpointsZ[i][j] ;
				if(landpointsZ[i][j] <minU)
					minU = landpointsZ[i][j] ;
			}
		}//end of for	

	}

	private void plotTrajTablePanel() {
		//button Panel
		JPanel buttonPanel = new JPanel();
		JButton pausestartButton = new JButton("Start Animation");
		JButton cancelAnimationButton = new JButton("Close");

		buttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.X_AXIS));
		buttonPanel.add(pausestartButton); buttonPanel.add(cancelAnimationButton);

		TBHandler TB=new TBHandler(6);       
		pausestartButton.addActionListener(TB);
		TB=new TBHandler(7);       
		cancelAnimationButton.addActionListener(TB);

		//table panel
		trajDataTableItem = new TrajDataTable(time, trajDataY, geneNames, colors);
		JPanel tableDataPanel = trajDataTableItem.getTabledataPanel();

		trajTablePanel.removeAll();
		trajTablePanel.add(buttonPanel); 
		trajTablePanel.add(tableDataPanel);
		trajTablePanel.updateUI();
	}

	private void plotTrajLinePanel() {
		linegraph = new MultipleLineGraph(trajDataY, time, trajDataTableItem.getTable(), colors);

		//define selected genes
		for(int i=0;i<geneNames.length;i++)
			selectedGenes.add(i);

		//select gene panel
		JPanel selectGenesPanel = new JPanel();
		selectGenesPanel.setPreferredSize(new Dimension(70, 450));
		selectGenesPanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 6));
		int count=0;
		for(String geneName: geneNames){
			Color currentColor = linegraph.getColors()[count];
			java.awt.Color color = new java.awt.Color(currentColor.r, currentColor.g, currentColor.b);

			checkBoxes[count] = new JCheckBox(geneName, true);
			checkBoxes[count].setForeground(color);
			checkBoxes[count].addItemListener(new ItemListener(){
				@Override
				public void itemStateChanged(ItemEvent e) {
					JCheckBox cb = (JCheckBox) e.getItem();
					String changedGene = cb.getText();

					ArrayList<List<LineStrip>> ls_ps = linegraph.getLs_ps();
					List<MyPickablePoint> points = linegraph.getPoints();
					//update selected Genes
					if( cb.isSelected() ){
						for(int i=0;i<geneNames.length;i++)
							if( geneNames[i].equals(changedGene) ){
								selectedGenes.add(i);
								//update line graph
								for( LineStrip ls: ls_ps.get(i) )
									ls.setDisplayed(true);
								for(int j=time.length*i;j<time.length*i+time.length;j++)
									points.get(j).setDisplayed(true);
							}

					}else{
						for(int i=0;i<geneNames.length;i++)
							if( geneNames[i].equals(changedGene) ){
								selectedGenes.remove((Object) i);
								//update line graph
								for( LineStrip ls: ls_ps.get(i) )
									ls.setDisplayed(false);
								for(int j=time.length*i;j<time.length*i+time.length;j++)
									points.get(j).setDisplayed(false);
							}
					}
				}			
			});

			JPanel tempPanel = new JPanel();
			tempPanel.setLayout(new BoxLayout(tempPanel, BoxLayout.X_AXIS));
			tempPanel.add(checkBoxes[count]);
			tempPanel.add(new LineLegendPanel(color));

			selectGenesPanel.add(tempPanel);

			count+=1;
		}



		JScrollPane scrollPane = new JScrollPane(selectGenesPanel);
		scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED); 
		scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);


		trajLinePanel.removeAll();
		trajLinePanel.add( (Component) linegraph.getChart().getCanvas(), BorderLayout.CENTER);
		trajLinePanel.add( scrollPane, BorderLayout.EAST);
		trajLinePanel.updateUI();
	}



	private void plotTrajPanel() {
		JLabel label = new JLabel("Set initial value: ");

		radio_set = new JRadioButton("Define the initial position");	
		final JRadioButton radio_select = new JRadioButton("Select the start point from the landscape");

		if( isProbabilisticLandscape )
			radio_select.setVisible(false);

		ButtonGroup loadOutput = new ButtonGroup();
		loadOutput.add(radio_select);
		loadOutput.add(radio_set);

		//		JButton submit = new JButton("Submit");
		//		JButton cancel = new JButton("Cancel");

		//		JPanel buttons = new JPanel();
		//		buttons.setPreferredSize(new java.awt.Dimension(100, 100));
		//		buttons.setLayout(new BoxLayout(buttons, BoxLayout.X_AXIS));
		//		buttons.add(submit); buttons.add(cancel);

		trajControlPanel.add(label);trajControlPanel.add(radio_select);
		trajControlPanel.add(radio_set);
		//		trajControlPanel.add(buttons);
		trajControlPanel.setVisible(false);

		//select a point from landscape
		radio_select.addActionListener(new ActionListener(){
			public void actionPerformed(ActionEvent e){
				if(radio_select.isSelected()){
					JOptionPane.showMessageDialog(null, "Double click cells in the table below to set the initial point.", "Info", JOptionPane.INFORMATION_MESSAGE);
				}
			}
		});
		radio_select.setSelected(true);

		//define initial value
		TBHandler TB=new TBHandler(8);       
		radio_set.addActionListener(TB);

	}



	private void plotControlPanel() {
		contourButton = new JButton("Show the contour map");
		JButton interactiveWithGraphButton = new JButton("Select points from the landscpae");
		JButton viewGraphButton = new JButton("Show the landscape");
		JButton mapTrajButton = new JButton("Map a trajectory");


		TBHandler TB=new TBHandler(0);       
		contourButton.addActionListener(TB);
		TB=new TBHandler(1);       
		interactiveWithGraphButton.addActionListener(TB);  
		TB=new TBHandler(2);       
		viewGraphButton.addActionListener(TB);  
		TB=new TBHandler(3);       
		mapTrajButton.addActionListener(TB);

		GridLayout layout1 = new GridLayout(2,2);
		layout1.setHgap(10);
		layout1.setVgap(10);

		controlPanel.setLayout(layout1);     
		controlPanel.add(contourButton); controlPanel.add(interactiveWithGraphButton);
		controlPanel.add(viewGraphButton); controlPanel.add(mapTrajButton);		
	}

	private void plotLandscapePanel() {
		org.jzy3d.chart.Settings.getInstance().setHardwareAccelerated(true);
		final ICanvas canvas = landscapeChart.getCanvas();

		//draw 
		JLabel instructionLabel = instructions();
		instructionLabel.setOpaque(false);
		instructionLabel.setBounds(10, 10, 200, 100);


		landscapePanel.add(instructionLabel, java.awt.BorderLayout.BEFORE_FIRST_LINE);
		landscapePanel.add( (Component)canvas, java.awt.BorderLayout.CENTER);


		this.addWindowListener(new WindowAdapter() { 
			public void windowClosing(WindowEvent e) {
				remove((java.awt.Component)canvas);
				landscapeChart.dispose();
			}
		});			
	}

	private void initialSelectFromTable(){
		dataTable.setRowSelectionInterval(dataTable.getRowCount() - 1, dataTable.getRowCount() - 1);
		dataTable.grabFocus();
		dataTable.changeSelection(1, 1, false, false);		
	}

	private class TBHandler implements ActionListener
	{
		private int funcNum = 1;


		public TBHandler(int funcNum){
			this.funcNum = funcNum;
		}

		public void actionPerformed(ActionEvent e)
		{      		
			if( funcNum == 0 ){ showContour(); } 
			else if( funcNum == 1 ){ interactiveWithGraph((JButton)e.getSource()); }
			else if( funcNum == 2 ){ viewGraph(); }
			else if( funcNum == 3 ){ mapTraj(); }
			else if( funcNum == 4 ){ mapTrajSubmit((JDialog)((JButton)e.getSource()).getParent().getParent().getParent().getParent().getParent().getParent()); }
			else if( funcNum == 5 ){ mapTrajCancel((JDialog)((JButton)e.getSource()).getParent().getParent().getParent().getParent().getParent().getParent()); }
			else if( funcNum == 6 ){ mapTrajStartPauseAnimation((JButton)e.getSource()); }
			else if( funcNum == 7 ){ mapTrajCancelAnimation(); }
			else if( funcNum == 8 ){ selectInitialStateForMapTraj(); }
			else{ } //other	
		}

		private void selectInitialStateForMapTraj() {
			final JDialog a = new JDialog();
			a.setTitle("Fixed initial values");
			a.setSize(new Dimension(400,400));

			JLabel noteLabel = new JLabel();
			noteLabel.setText("Please set the initial values");

			JPanel speciesPanel = new JPanel();
			String[] columnName = {"Name", "InitialValue"};
			boolean editable = true; //false;
			new SpeciesTable(speciesPanel, columnName, grn_, editable);

			JPanel buttonsPanel = new JPanel();
			JButton submit = new JButton("Submit");
			JButton cancel = new JButton("Cancel");
			buttonsPanel.add(submit); buttonsPanel.add(cancel);


			TBHandler TB=new TBHandler(4);       
			submit.addActionListener(TB);
			TB=new TBHandler(5);       
			cancel.addActionListener(TB);

			/** LAYOUT **/
			JPanel wholePanel = new JPanel();

			wholePanel.setLayout(new BoxLayout(wholePanel, BoxLayout.Y_AXIS));
			wholePanel.add(noteLabel); wholePanel.add(speciesPanel);
			wholePanel.add(buttonsPanel);

			a.add(wholePanel);
			a.setModal(true);
			a.setLocationRelativeTo(null);
			a.setVisible(true);						
		}

		private void mapTrajCancelAnimation() {
			animationStop();

			controlPanel.setVisible(true);
			contourTablePanel.setVisible(true);
			trajControlPanel.setVisible(false);
			trajLinePanel.setVisible(false);
			trajTablePanel.setVisible(false);

			clearPathOnLandscape();
		}


		private void mapTrajStartPauseAnimation(JButton jButton) {			
			//pause
			if(jButton.getText().equals("Pause")){
				jButton.setText("Continue");
				t.suspend();
			}else 
				//start
				if(jButton.getText().equals("Start Animation")){
					//block checkboxes
					for(JCheckBox j: checkBoxes)
						j.setEnabled(false);

					jButton.setText("Pause");
					animationStart(jButton);
				}else 
					//resume	
					if(jButton.getText().equals("Continue")){
						jButton.setText("Pause");
						t.suspend();
					}
		}

		private void mapTrajSubmit(JDialog a) {
			trajControlPanel.setVisible(false);
			contourTablePanel.setVisible(false);

			a.dispose();

			//calculate traj
			int len = calculateTraj();					

			try {	
				//display 
				//filter data from time series
				int interval = len<100?1:len/20;
				int numItem = (len-1)/interval+1;

				time = new double[numItem];
				trajDataY = new double[nGenes][numItem];
				int count = 0;

				int aaa = grn_.getTimeSeries().get(0).rows();

				for(int i=0;i<len;i+=interval){
					time[i] = grn_.getTimeScale().get(0).get(i);
					for(int j=0;j<nGenes;j++)
						trajDataY[j][count] = grn_.getTimeSeries().get(0).get(i, j);
					count++;
				}

				grn_.getTimeScale().set(0, new DenseDoubleMatrix1D(time));
				grn_.getTimeSeries().set(0, (new DenseDoubleMatrix2D(trajDataY)).viewDice());

				//				time = grn_.getTimeScale().get(0).toArray();
				//				trajDataY = grn_.getTimeSeries().get(0).viewDice().toArray();

				if( isProbabilisticLandscape ){
					trajDataInLandX = grn_.getTimeSeries().get(0).viewColumn(combo1.getSelectedIndex()).toArray();
					trajDataInLandY = grn_.getTimeSeries().get(0).viewColumn(combo2.getSelectedIndex()).toArray();

					trajDataInLandZ = new double[trajDataInLandX.length];

					calculateLandUPro(combo1.getSelectedIndex(), combo2.getSelectedIndex());

				}else{
					//TODO open a new thread
					//Messages.progressMessage("Mapping data");
					//run GPDM
					//input file
					String filename = "temp_"+System.currentTimeMillis();
					String temppath = System.getProperty("java.io.tmpdir");
					File f = new File(temppath);

					File fTemp = File.createTempFile(filename, ".svml", f);

					URL url = fTemp.toURI().toURL();
					int lines = writeSVML(url, trajDataY, grn_.getAllY());

					//output file
					String outputModelName = "temp_"+System.currentTimeMillis();
					File fout = new File(temppath);
					File fTempout = File.createTempFile(outputModelName, ".gpdm", fout);

					//run GPDM
					int exitVal = runGPDM(temppath,fTemp.getName(),fTempout.getName(), 2);

					if( exitVal == 0 ){
						DoubleMatrix2D allY = new DenseDoubleMatrix2D(lines, nGenes);
						DoubleMatrix2D allX = new DenseDoubleMatrix2D(lines, 2);

						getYandX(fTempout, allY, allX, lines);
						trajDataInLandX = allX.viewColumn(0).toArray();
						trajDataInLandY = allX.viewColumn(1).toArray();

						trajDataInLandZ = new double[trajDataInLandX.length];

						calculateLandUGPDM(allY);

					}else{
						JOptionPane.showMessageDialog(null, "Error in running of GPDM.", "Error", JOptionPane.ERROR_MESSAGE);
					}

				}

				// Init graph color
				setColors();

				//draw trajTablePanel
				plotTrajTablePanel();	

				//draw trajLinePanel
				plotTrajLinePanel();

				trajLinePanel.setVisible(true);
				trajTablePanel.setVisible(true);

			} catch (Exception e1) {
				JOptionPane.showMessageDialog(null, "Error in calculation of trajectories.", "Error", JOptionPane.ERROR_MESSAGE);
				MsgManager.Messages.errorMessage(e1, "Error", "");
			} 	



		}


		private int calculateTraj() {
			int len = 0;

			int numPoints = grn_.getLand_maxTime()*2+1;
			SDESolver deSolver_ = new SDESolver(grn_);
			deSolver_.setNumSeries(1);
			deSolver_.setMaxt(grn_.getLand_maxTime());
			deSolver_.setNumTimePoints(numPoints);
			deSolver_.setRandomInitial(false);

			deSolver_.setNoiseStrength(0);

			deSolver_.setDt(0);

			deSolver_.setIslandscape(false);

			deSolver_.setSimulateODE(true);
			deSolver_.setSimulateSDE(false);
			deSolver_.setODE(true);			

			try {
				deSolver_.solveEquations_SDE();

				//check if converge
				DoubleMatrix1D lasttime = grn_.getTimeSeries().get(0).viewRow(numPoints-1);
				DoubleMatrix1D secondlasttime = grn_.getTimeSeries().get(0).viewRow(numPoints-2);

				DoubleMatrix1D time = grn_.getTimeScale().get(0).copy();
				DoubleMatrix2D timecourse = grn_.getTimeSeries().get(0).copy();

				cern.jet.math.Functions F = cern.jet.math.Functions.functions;
				while( lasttime.aggregate(secondlasttime, F.plus, F.chain(F.square, F.minus))>0.001 ){
					grn_.setInitialState(lasttime);
					grn_.setSpecies_initialState(lasttime);

					deSolver_.solveEquations_SDE();

					time = combineTwo1DMatrix(time,grn_.getTimeScale().get(0)).copy();
					timecourse = DoubleFactory2D.dense.appendRows(timecourse, grn_.getTimeSeries().get(0));

					grn_.getTimeScale().set(0, time);
					grn_.getTimeSeries().set(0, timecourse);	

					lasttime = grn_.getTimeSeries().get(0).viewRow(grn_.getLand_maxTime()*2);
					secondlasttime = grn_.getTimeSeries().get(0).viewRow(grn_.getLand_maxTime()*2-1);
				}


				//get unique states			
				for(int j=0;j<timecourse.rows();j++){
					if( lasttime.aggregate(timecourse.viewRow(j), F.plus, F.chain(F.square, F.minus))<0.001 ){
						len = j;
						break;
					}
					len++;
				}

				len = len<20?20:len;

				//update grn_
				grn_.getTimeScale().set(0, grn_.getTimeScale().get(0).viewPart(0, len));
				grn_.getTimeSeries().set(0, grn_.getTimeSeries().get(0).viewPart(0, 0, len, nGenes));	



			} catch (Exception e) {
				Messages.errorMessage(e, "Error in generation of trajectory", "");
			}
			return len;

		}

		private DoubleMatrix1D combineTwo1DMatrix(DoubleMatrix1D m1, DoubleMatrix1D m2){
			DoubleMatrix1D output = new DenseDoubleMatrix1D(m1.size()+m2.size());
			for(int i=0;i<m1.size();i++)
				output.set(i, m1.get(i));
			for(int i=0;i<m2.size();i++)
				output.set(i+m1.size(), m2.get(i));

			return output;			
		}



		private void calculateLandUPro(int indexX, int indexY) {
			double its = 0;
			for(int i=0;i<grn_.getCounts().length;i++)
				its += grn_.getCounts()[i];

			double maxU = 0; double minU = 100000;
			for(int i=0;i<trajDataInLandZ.length;i++){
				double u = 0;
				//all types
				for(int k1=0;k1<grn_.getSumPara().rows();k1++){
					double u1 = Math.exp(-1.0*Math.pow((trajDataInLandX[i]-grn_.getSumPara().get(k1, indexX)), 2)/2.0/grn_.getSumPara().get(k1, indexX+nGenes))/grn_.getSumPara().get(k1, indexX+nGenes)/Math.sqrt(2.0*Math.PI);
					double u2 = Math.exp(-1.0*Math.pow((trajDataInLandY[i]-grn_.getSumPara().get(k1, indexY)), 2)/2.0/grn_.getSumPara().get(k1, indexY+nGenes))/grn_.getSumPara().get(k1, indexY+nGenes)/Math.sqrt(2.0*Math.PI);
					u += u1*u2*grn_.getCounts()[k1]/its;
				}

				double up = -1.0*Math.log(u);
				if( up>100 )
					up=100;

				trajDataInLandZ[i] = up;


				if(trajDataInLandZ[i] >maxU)
					maxU = trajDataInLandZ[i] ;
				if(trajDataInLandZ[i] <minU)
					minU = trajDataInLandZ[i] ;
			}
		}//end of for	


	}

	private void calculateLandUGPDM(DoubleMatrix2D allY) {
		double its = 0;
		for(int i=0;i<grn_.getCounts().length;i++)
			its += grn_.getCounts()[i];

		double maxU = 0; double minU = 100000;
		for(int i=0;i<trajDataInLandZ.length;i++){
			DoubleMatrix1D currentY = allY.viewRow(i);
			double u = 0;
			//all types
			for(int k1=0;k1<grn_.getSumPara().rows();k1++){
				double u1 = 1;
				for(int index=0;index<currentY.size();index++){
					currentY.set(index, Math.abs(currentY.get(index)));
					u1 *= Math.exp(-1.0*Math.pow((currentY.get(index)-grn_.getSumPara().get(k1, index)), 2)/2.0/grn_.getSumPara().get(k1, index+nGenes))/grn_.getSumPara().get(k1, index+nGenes)/Math.sqrt(2.0*Math.PI);
				}

				//in case that u1 is too large
				if( u1>100 )
					u1=100;
				u += u1*grn_.getCounts()[k1]/its;
			}

			double up = -1.0*Math.log(u);
			if( up>100 )
				up=100;

			trajDataInLandZ[i] = up;


			if(trajDataInLandZ[i] >maxU)
				maxU = trajDataInLandZ[i] ;
			if(trajDataInLandZ[i] <minU)
				minU = trajDataInLandZ[i] ;

		}
	}

	private void getYandX(File fTempnew, DoubleMatrix2D allY, DoubleMatrix2D allX, int lines) {
		//get ogrinal Y and X
		BufferedReader reader = null;
		try {
			reader = new BufferedReader(new FileReader(fTempnew));
			String tempString = null;
			//get minX maxX minY maxY
			int line = 0;
			while ((tempString = reader.readLine()) != null && !tempString.startsWith("Y:")) {}
			while ((tempString = reader.readLine()) != null && line<lines){
				String temp[] = tempString.split(" ");
				for(int i=0;i<nGenes;i++)
					allY.set(line, i, Double.parseDouble(temp[i]));
				for(int i=nGenes;i<temp.length-1;i++)
					allX.set(line, i-nGenes, Double.parseDouble(temp[i]));
				line+=1;
			}
			reader.close();

		} catch (IOException e) {
			JOptionPane.showMessageDialog(null, "Error in reading the file!", "Error", JOptionPane.INFORMATION_MESSAGE);
			MsgManager.Messages.errorMessage(e, "Error", "");
		} finally {
			if (reader != null) {
				try {
					reader.close();                 
				} catch (IOException e1) {
					JOptionPane.showMessageDialog(null, "Error in reading the file!", "Error", JOptionPane.INFORMATION_MESSAGE);
					MsgManager.Messages.errorMessage(e1, "Error", "");
				}
			}
		}

	}

	private int runGPDM(String filePath, String filename, String outputModelName, int gpdmItsValue){	
		int exitVal = -1;
		Runtime rn = Runtime.getRuntime();
		Process p = null;
		try {
			//				//for standalone package
			//				String programPath = getClass().getProtectionDomain().getCodeSource().getLocation().getPath();	
			//
			//
			//				String os = System.getProperty("os.name");  		
			//				if(os.toLowerCase().startsWith("win")){   
			//					programPath = programPath.replaceAll("^/", "");
			//					programPath = programPath.replaceAll("\\/", "\\\\");	
			//					programPath = programPath.substring(0, programPath.lastIndexOf("\\")+1)+"GPDM\\win";
			//					programPath = programPath.replaceAll("%20"," ");
			//					p = rn.exec("cmd /C gplvm.exe -v 3 learn -L true -D rbf -# "+gpdmItsValue+" "+filePath+"\\"+filename+" "+filePath+"\\"+outputModelName,null, new File(programPath));
			//				}else if(os.toLowerCase().startsWith("linux")){ 
			//					p = rn.exec("./GPDM/linux/gplvm -v 3 learn -L true -D rbf -# "+gpdmItsValue+" "+filePath+"/"+filename+" "+filePath+"/"+outputModelName);
			//				}else if(os.toLowerCase().startsWith("mac")){ 
			////					programPath = programPath.substring(0, programPath.lastIndexOf("/")+1)+"GPDM/mac";
			////					programPath = programPath.replaceAll("%20","\" \"");
			//					p = rn.exec("./GPDM/mac/gplvm -v 3 learn -L true -D rbf -# "+gpdmItsValue+" "+filePath+"/"+filename+" "+filePath+"/"+outputModelName);
			//				}


			//for ide
			String programPath = "E:\\netland\\workspace\\NetLand\\GPDM\\win";			
			p = rn.exec("cmd /C gplvm.exe -v 3 learn -L true -D rbf -# "+gpdmItsValue+" "+filePath+"\\"+filename+" "+filePath+"\\"+outputModelName,null, new File(programPath));

			System.out.print("Run GPDM \n"); //+programPath+"\n"+filePath+"\n"+outputModelName+"\n"


			BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
			String msg = null;
			while ((msg = br.readLine()) != null) {
				System.out.println(msg);
				if( msg.equals("Press enter for more") ){
					p.destroy();
					JOptionPane.showMessageDialog(null, "Please try again.", "Error exec gpdm!", JOptionPane.INFORMATION_MESSAGE);
				}
				checkForInterruption_process(p);
			}

			exitVal = p.waitFor();
			//				System.out.println("Process exitValue gpdm: " + exitVal);
		} catch (Exception e) {
			JOptionPane.showMessageDialog(null, "Error in execution of GPDM!", "Error", JOptionPane.INFORMATION_MESSAGE);
			MsgManager.Messages.errorMessage(e, "Error", "");
		}
		return exitVal;	
	}

	private void checkForInterruption_process(Process p) throws CancelException {	
		if (GnwSettings.getInstance().stopBenchmarkGeneration()){ 
			p.destroy();
			throw new CancelException("Generation canceled!");
		}
	}

	private int writeSVML(URL filename, double[][] trajDataY, DoubleMatrix2D orinY) {
		//cannot take all data
		//			int n2 = (grn_.getLand_maxTime()*2+1)/20;
		int lines = 0;

		// Create a new file	
		FileWriter fw;
		try {
			fw = new FileWriter(filename.getPath());

			//write trajectories
			for(int j=0;j<time.length;j+=1){
				String temp = "0";
				for(int k=0;k<nGenes;k++)
					temp += " "+(k+1)+":"+trajDataY[k][j];
				fw.write(temp+"\n");
				lines++;
			}

			for(int j=0;j<orinY.rows();j++){
				String temp = "0";
				for(int k=0;k<nGenes;k++)
					temp += " "+(k+1)+":"+orinY.get(j,k);
				fw.write(temp+"\n");
			}

			fw.close();   
		} catch (IOException e) {
			System.out.print("Cannot create file!");
		}   
		return lines;
	}

	private void mapTrajCancel(JDialog a) {
		controlPanel.setVisible(true);
		contourTablePanel.setVisible(true);
		trajControlPanel.setVisible(false);

		a.dispose();
	}

	private void mapTraj() {
		//set visible
		controlPanel.setVisible(false);
		trajControlPanel.setVisible(true);
		//initialSelectFromTable();	
	}

	private void viewGraph() {
		surface.setDisplayed(true);
	}

	private void interactiveWithGraph(JButton source) {
		surface.setDisplayed(false);	
	}




	private void showContour() {	
		landscapeChart.getView().setBoundManual(bounds);

		if(contourButton.getText().equals("Show the contour map")){
			contourButton.setText("Hide the contour map");
			createContourMap();
		}else{
			contourButton.setText("Show the contour map");
			ContourAxeBox newcab = new ContourAxeBox(bounds); 
			landscapeChart.getView().setAxe(newcab);
		}
	}

	public void setColors() {
		this.colors = new Color[nGenes];

		ArrayList<Random> nums = new ArrayList<Random>(nGenes);
		for(int i=0;i<nGenes;i++){
			Random r=new Random();
			while( nums.contains(r) ){
				r=new Random();
			}
			nums.add(r);
			Color color = new Color(r.nextInt(256),r.nextInt(256),r.nextInt(256));
			colors[i] = color;
		}

	}

	private void createContourMap() {
		//double[] to arraylist
		final ArrayList<Double> landpointsXList = new ArrayList<Double>(landpointsX.length);
		final ArrayList<Double> landpointsYList = new ArrayList<Double>(landpointsY.length);
		for(int i=0;i<landpointsX.length;i++)
			landpointsXList.add(landpointsX[i]);
		for(int i=0;i<landpointsY.length;i++)
			landpointsYList.add(landpointsY[i]);

		// Define a function to plot
		Mapper mapper = new Mapper() {
			public double f(double x, double y) {
				int indexx = landpointsXList.indexOf((Math.rint(x*1000))/1000.0);
				int indexy = landpointsYList.indexOf((Math.rint(y*1000))/1000.0);

				return landpointsZ[indexx][indexy];
			}
		};


		/**        contour           **/
		// Define range and precision for the function to plot
		Range rangex = new Range(getMin(landpointsX), getMax(landpointsX));
		Range rangey = new Range(getMin(landpointsY), getMax(landpointsY));

		// Create a chart and add the surface	
		myColorMapper = new ColorMapper(new ColorMapRainbow(), getMin(landpointsZ), getMax(landpointsZ), new Color(1, 1, 1, .5f));

		ContourAxeBox cab = (ContourAxeBox) landscapeChart.getView().getAxe(); //new ContourAxeBox(box , chart.getView().getAxe().getLayout()); //
		MapperContourPictureGenerator contour = new MapperContourPictureGenerator(mapper, rangex, rangey);
		cab.setContourImg( contour.getContourImage(new DefaultContourColoringPolicy(myColorMapper), landpointsX.length, landpointsY.length, 30), rangex, rangey);
		//getContourImage //getFilledContourImage

	}


	private void clearPathOnLandscape(){
		//clear path on landscape
		List<AbstractDrawable> gidges = landscapeChart.getScene().getGraph().getAll();
		int totalNum = gidges.size();
		for(int i=totalNum-1;i>961;i--)
			landscapeChart.removeDrawable(gidges.get(i),false);
	}

	private void clearAllinChart(){
		landscapeChart.removeDrawable(surface);
		for(int i=0;i<points.size();i++)
			landscapeChart.removeDrawable(points.get(i),false);
	}

	public void createDrawingChart(){	
		landscapeChart = new ContourChart(Quality.Fastest);	

		//generate points
		coords = getSurf();

		/**        surface           **/
		createSurface();

		//generate pickable points
		createPickablePoints();

		/**        control           **/
		landscapeChart.addKeyController();
		landscapeChart.addScreenshotKeyController();
		System.out.print(Utils.dat2str(new Date()));

		landscapeChart.addController(new AWTCameraMouseController(){
			@Override
			public void mousePressed(MouseEvent e) {
			}
		});


		//set x label  y label
		landscapeChart.getScene().getGraph().add(surface);
		landscapeChart.getScene().getGraph().add( points );	

		//define bounds
		bounds = landscapeChart.getView().getBounds();


		fpsText = "";
		landscapeChart.addRenderer(new Renderer2d(){
			public void paint(Graphics g) {
				Graphics2D g2d = (Graphics2D)g;
				g2d.setColor(java.awt.Color.BLACK);
				g2d.drawString(fpsText, 50, 50);
			}
		});

		landscapeChart.render();

	}

	private void createSurface() {
		/**        surface           **/
		surface = (Shape) Builder.buildDelaunay(coords);
		myColorMapper = new ColorMapper(new ColorMapRainbow(), surface.getBounds().getZmin(), surface.getBounds().getZmax(), new Color(1, 1, 1, .5f));
		surface.setColorMapper(myColorMapper);
		surface.setFaceDisplayed(true);
		surface.setWireframeDisplayed(false);
		surface.setWireframeColor(Color.BLACK);
		//legend
		surface.setLegend(new AWTColorbarLegend(surface,landscapeChart.getView().getAxe().getLayout()));
		surface.setLegendDisplayed(true);
	}

	private void createPickablePoints(){
		/**        pickable points           **/
		myColorMapper = new ColorMapper(new ColorMapRainbow(), surface.getBounds().getZmin(), surface.getBounds().getZmax(), new Color(1, 1, 1, .5f));

		//pickable points
		points = new ArrayList<>();

		for(int i = 0; i < coords.size(); i++) {
			Coord3d newcoord = new Coord3d(coords.get(i).x,coords.get(i).y,coords.get(i).z);
			points.add(new MyPickablePoint(i%landpointsX.length, (int)i/landpointsX.length, newcoord, myColorMapper.getColor(newcoord), 5));
		}


		/**        picking control       **/
		//mouse selection
		MyMousePickingController<?,?> mousePicker = new MyMousePickingController<>(landscapeChart, 5);
		PickingSupport picking = mousePicker.getPickingSupport();


		for(MyPickablePoint p : points) {
			picking.registerPickableObject(p, p);	
		}

		picking.addObjectPickedListener(new IObjectPickedListener() {
			@Override
			public void objectPicked(List<?> picked, PickingSupport ps) {
				if (picked.isEmpty()) {  
					//System.out.println("Nothing was picked.");	
					for(Object p: points){
						((MyPickablePoint) p).setColor(myColorMapper.getColor(((MyPickablePoint) p).xyz));
						((MyPickablePoint) p).setWidth(5);
					}
				} else {
					for(Object p: points){
						if( picked.get(0) == p ){
							System.out.println(p);
							((MyPickablePoint) p).setColor(Color.RED);
							((MyPickablePoint) p).setWidth(7);

							dataTable.setRowSelectionInterval(dataTable.getRowCount() - 1, dataTable.getRowCount() - 1);
							dataTable.grabFocus();
							dataTable.changeSelection(((MyPickablePoint) p).getColNo(), ((MyPickablePoint) p).getRowNo(), false, false);
						}else{
							((MyPickablePoint) p).setColor(myColorMapper.getColor(((MyPickablePoint) p).xyz));
							((MyPickablePoint) p).setWidth(5);
						}
					}
				}
			}
		});


	}

	public JLabel instructions(){
		JLabel instructionLabel = new JLabel();
		instructionLabel.setText("<html>"+
				"Rotate     : Left click and drag mouse<br>"+
				"Scale      : Roll mouse wheel<br>"+
				"Z Shift    : Right click and drag mouse<br>"+
				"Screenshot : Press 's'<br>"+
				"</html>"+
				"------------------------------------");
		return instructionLabel;
	}

	public List<Coord3d> getSurf(){
		int rows = landpointsX.length;

		List<Coord3d> coords = new ArrayList<Coord3d>(rows*rows);

		for(int i=0;i<rows;i++)
			for(int j=0;j<rows;j++)
				coords.add(new Coord3d((float) landpointsX[i],(float) landpointsY[j],(float) landpointsZ[i][j]));	

		return coords;
	}



	public void animationStop(){
		if(t!=null){
			t.suspend();
			t.stop();

			//clear path in landscape
			clearPathOnLandscape();
			fpsText = "";
		}
	}

	public void animationStart(JButton jButton){
		final List<Coord3d> trajCoords = getSurf(trajDataInLandX, trajDataInLandY, trajDataInLandZ);
		final List<MyPickablePoint> points = linegraph.getPoints();
		List<List<LineStrip>> ls_ps = linegraph.getLs_ps();

		clearPathOnLandscape();
		linegraph.removeLine();

		//set points and ls_ps invisible
		for(Object p: points)
			((MyPickablePoint) p).setDisplayed(false);
		for(int i=0;i<ls_ps.size();i++)
			for(int j=0;j<ls_ps.get(0).size();j++)
				ls_ps.get(i).get(j).setDisplayed(false);

		//time=0
		linegraph.getChart().getScene().getGraph().add( points.get(0) );
		landscapeChart.getScene().getGraph().add(new Point(trajCoords.get(0), Color.RED, 5));

		trajDataTableItem.getTable().setRowSelectionInterval(0, 0);
		trajDataTableItem.getTable().grabFocus();
		trajDataTableItem.getTable().changeSelection(0, 0, true, true);  


		//time>0
		t = new myThread();
		t.setTrajCoords(trajCoords);
		t.setjButton(jButton);
		t.start();
	}



	private List<Coord3d> getSurf(double[] trajDataInLandX2, double[] trajDataInLandY2, double[] trajDataInLandZ2) {
		List<Coord3d> coords = new ArrayList<Coord3d>(trajDataInLandX2.length);

		for(int i=0;i<trajDataInLandX2.length;i++)
			coords.add(new Coord3d((float) trajDataInLandX2[i],(float) trajDataInLandY2[i],(float) trajDataInLandZ2[i]));

		return coords;
	}

	public class myThread implements Runnable{
		private Thread myThread;
		private long interval=1000;
		private volatile boolean threadSuspended;
		private TicToc tt = new TicToc();
		private List<Coord3d> trajCoords;
		private JButton jButton;

		public void start(){
			myThread=new Thread(this,"myThread");
			myThread.start();
		}


		@Override
		public void run() {
			Thread thisThread=Thread.currentThread();
			System.out.println("Animation is ON.\n");

			int count = 1;
			//clearPathOnLandscape();
			while(myThread==thisThread && count<time.length){
				try {
					Thread.sleep(interval);
				} catch (InterruptedException e) {
					System.out.print("Animation is interrupted!\n");	
					//clear path in landscape
					clearPathOnLandscape();
					fpsText = "";
				}
				tt.tic();

				//animation on landscape
				LineStrip ls = new LineStrip();
				Point newpoint1 = new Point(trajCoords.get(count-1), Color.RED, 5);
				Point newpoint2 = new Point(trajCoords.get(count), Color.RED, 5);
				ls.setWireframeColor(Color.BLACK);
				ls.add(newpoint1);
				ls.add(newpoint2);

				landscapeChart.getScene().getGraph().add(ls);
				landscapeChart.getScene().getGraph().add(newpoint2);

				//animation on traj data table
				trajDataTableItem.getTable().setRowSelectionInterval(count, count);
				trajDataTableItem.getTable().grabFocus();
				trajDataTableItem.getTable().changeSelection(count, 0, true, true);                


				//animation on trajlinePanel
				for(int i: selectedGenes){
					linegraph.getLs_ps().get(i).get(count-1).setDisplayed(true);
					linegraph.getPoints().get(i*time.length+count).setDisplayed(true);
				}

				tt.toc();
				fpsText = "Time: " + time[count];
				count++;

				if(threadSuspended&&myThread==thisThread){
					synchronized(this){
						while(threadSuspended&&myThread==thisThread){
							try {
								wait();
							} catch (InterruptedException e) {
								System.out.println("Animation is interrupted by InterruptedException.");
							}
						}
					}
				}

			}
			System.out.println("Animation is over.\n");

			//end of thread
			jButton.setText("Start Animation");
			//unblock checkboxes
			for(JCheckBox j: checkBoxes)
				j.setEnabled(true);	
		}





		public synchronized void stop(){
			if(myThread==null){
				return;
			}
			Thread moribund=myThread;
			myThread=null;
			moribund.interrupt();
		}

		public synchronized void suspend(){
			threadSuspended=!threadSuspended;
			if(!threadSuspended){
				notify();
			}
		}



		public List<Coord3d> getTrajCoords() {
			return trajCoords;
		}



		public void setTrajCoords(List<Coord3d> trajCoords) {
			this.trajCoords = trajCoords;
		}

		public JButton getjButton() {
			return jButton;
		}


		public void setjButton(JButton jButton) {
			this.jButton = jButton;
		}
	}



	public double getMin(double[][] values){
		double minValue = 100000;
		for(int i=0;i<landpointsX.length;i++)
			for(int j=0;j<landpointsY.length;j++)
				if(minValue>values[i][j])
					minValue=values[i][j];

		return minValue;
	}

	public double getMax(double[][] values){
		double maxValue = -100000;
		for(int i=0;i<landpointsX.length;i++)
			for(int j=0;j<landpointsY.length;j++)
				if(maxValue<values[i][j])
					maxValue=values[i][j];

		return maxValue;
	}

	private double getMax(double[] values) {
		double maxValue = -100000;
		for(int i=0;i<values.length;i++)
			if(maxValue<values[i])
				maxValue=values[i];

		return maxValue;
	}

	private double getMin(double[] values) {
		double minValue = 100000;
		for(int i=0;i<values.length;i++)
			if(minValue>values[i])
				minValue=values[i];

		return minValue;
	}


	public void setLandpointsX(double[] landpointsX){
		this.landpointsX = landpointsX;		
	}

	public void setLandpointsY(double[] landpointsY){
		this.landpointsY = landpointsY;		
	}

	public void setLandpointsZ(double[][] landpointsZ){
		this.landpointsZ = landpointsZ;		
	}


	public double[] getTrajDataInLandX() {
		return trajDataInLandX;
	}

	public void setTrajDataInLandX(double[] trajDataInLandX) {
		this.trajDataInLandX = trajDataInLandX;
	}

	public double[] getTrajDataInLandY() {
		return trajDataInLandY;
	}

	public void setTrajDataInLandY(double[] trajDataInLandY) {
		this.trajDataInLandY = trajDataInLandY;
	}

	public double[] getTrajDataInLandZ() {
		return trajDataInLandZ;
	}

	public void setTrajDataInLandZ(double[] trajDataInLandZ) {
		this.trajDataInLandZ = trajDataInLandZ;
	}

	public double[] getTime() {
		return time;
	}

	public void setTime(double[] time) {
		this.time = time;
	}

	public boolean isProbabilisticLandscape() {
		return isProbabilisticLandscape;
	}

	public void setProbabilisticLandscape(boolean isProbabilisticLandscape) {
		this.isProbabilisticLandscape = isProbabilisticLandscape;
	}


}
